<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JHL, I Love You</title>
    <link href="/5201/01/14/JHL,%20I%20Love%20You/"/>
    <url>/5201/01/14/JHL,%20I%20Love%20You/</url>
    
    <content type="html"><![CDATA[<p><label>YT 😘 JHL</label><br><label id="div1"></label></p><script>    function time() {        var date1 = new Date('2020/12/30 21:0:0');    //开始时间        var date2 = new Date();        var date3 = date2.getTime() - date1.getTime(); //时间差秒        //计算出相差天数        var days = Math.floor(date3 / (24 * 3600 * 1000));        //计算出小时数        var leave1 = date3 % (24 * 3600 * 1000);  //计算天数后剩余的毫秒数        var hours = Math.floor(leave1 / (3600 * 1000));        //计算相差分钟数        var leave2 = leave1 % (3600 * 1000);       //计算小时数后剩余的毫秒数        var minutes = Math.floor(leave2 / (60 * 1000));        //计算相差秒数        var leave3 = leave2 % (60 * 1000);     //计算分钟数后剩余的毫秒数        var seconds = Math.round(leave3 / 1000);        var str = "我们相爱了 " + days + "天" + hours + "时" + minutes + "分" + seconds + "秒";        var div1 = document.getElementById("div1");        div1.innerHTML = str;    }    setInterval(time, 1000);</script>]]></content>
    
    
    <categories>
      
      <category>Love</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Love</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo配合vscode的使用</title>
    <link href="/2023/04/03/hexo%E9%85%8D%E5%90%88vscode%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/04/03/hexo%E9%85%8D%E5%90%88vscode%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="解决插入图片问题"><a href="#解决插入图片问题" class="headerlink" title="解决插入图片问题"></a>解决插入图片问题</h2><p>我们要实现在本地写markdown时，方便插入图片，能在vscode中正确预览，hexo发布后也能正确显示，可以安装一下步骤进行：</p><ol><li><p>安装截图工具<code>Snipaste</code></p><p>微软应用商店搜索下载即可</p><p>截图时可以选择将图片复制到剪贴板，并通过下面的插件将图片放到markdown中</p></li><li><p>安装vscode插件<code>Paste Image</code>，并作如下配置</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// .vscode/settings.json</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;pasteImage.path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;currentFileDir&#125;/$&#123;currentFileNameWithoutExt&#125;&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p> 这个插件可以将剪贴板中的图片插入到markdown中，通过上面的配置，在插入图片时，会在当前文件的路径下生成去除扩展名的文件夹，并将图片放到里面</p></li><li><p>安装<code>hexo-asset-image</code>插件</p><p> 这个插件能识别插入图片的路径，并在执行<code>hexo g</code>时生成正确的链接</p> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/CodeFalling/</span>hexo-asset-image --save<br></code></pre></td></tr></table></figure><p> 同时还要更改<code>_config.yml</code></p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gromacs-2020后处理分析程序编写教程</title>
    <link href="/2021/03/17/Gromacs-2020%E5%90%8E%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99%E6%95%99%E7%A8%8B/"/>
    <url>/2021/03/17/Gromacs-2020%E5%90%8E%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="起"><a href="#起" class="headerlink" title="起"></a>起</h2><p><a href="http://www.gromacs.org/">Gromacs</a>是一款十分优秀的分子动力学软件，其并行化运行速度快，且本身自带丰富的后处理命令。但在科研过程中难免会出现自带分析工具难以满足我们需求的情况，这时候就需要我们自己针对Gromacs产生的轨迹文件编写符合我们需求的后处理程序。本文介绍了针对Gromacs-2020系列版本的轨迹后处理分析过程，程序编写基于本人在研究生期间开发的后处理框架，开发平台为Windows 10-Visual Studio Community 2019，在Windows上编写代码就可以在Windows上编译运行，也可以把代码Copy到Linux服务器上编译运行。</p><h3 id="准备文件和工具"><a href="#准备文件和工具" class="headerlink" title="准备文件和工具"></a>准备文件和工具</h3><ol><li><p>Gmx2020后处理框架</p> <iframe src="https://onedrive.live.com/embed?cid=7E39B63375DD2896&resid=7E39B63375DD2896%2110282&authkey=ADQyMIEb66TTm5k" width="98" height="120" frameborder="0" scrolling="no"></iframe></li><li><p><a href="https://visualstudio.microsoft.com/zh-hans/vs/">Visual Studio Community 2019</a></p><p>安装时只需勾选<code>使用c++的桌面开发</code></p></li></ol><p>准备完成后，解压缩后处理框架，进入<code>Gmx2020_PostAnalysis_for_VS2019/Gmx2020PostAnalysis/</code>目录中，双击<code>Gmx2020PostAnalysis.sln</code>即可打开VS2019工程。</p><h2 id="承"><a href="#承" class="headerlink" title="承"></a>承</h2><h3 id="简单程序代码示例"><a href="#简单程序代码示例" class="headerlink" title="简单程序代码示例"></a>简单程序代码示例</h3><p>后处理程序由一个简单的示例引入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">///&lt;讲注：开头注释，记录程序作者、时间、邮箱以及描述</span><br><span class="hljs-comment">/*  Author     : TING</span><br><span class="hljs-comment"> *  Date       : 2019/05/05</span><br><span class="hljs-comment"> *  Email      : yeting2938@hust.edu.cn</span><br><span class="hljs-comment"> *  Desc       : calculate density along axis in simulation.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">///&gt;</span><br><br><span class="hljs-comment">///&lt;讲注：头文件，包含常用库和函数</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;itp/gmx&gt;</span></span><br><span class="hljs-comment">///&gt;</span><br><br><span class="hljs-comment">///&lt;讲注：位于命名空间`itp`下的类`GmxHandle`里面定义了绝大多数在轨迹分析过程中</span><br><span class="hljs-comment">/// 会用到的数据以及函数，比如体系的拓扑结构、分子与原子的数目、分子的质量与电量</span><br><span class="hljs-comment">/// 等数据结构，获取分子位置、速度、受力等函数，会在下节详细讲解。这里是构造一个</span><br><span class="hljs-comment">/// 继承类，里面可以定义一些在本代码中会用到的数据以及函数。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Handle</span> : <span class="hljs-keyword">public</span> itp::GmxHandle<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">using</span> GmxHandle::GmxHandle;<br><br><span class="hljs-keyword">public</span>:<br>itp::boxd pos1;<br>itp::matd posc1;<br>&#125;;<br><span class="hljs-comment">///&gt;</span><br><br><span class="hljs-comment">///&lt;讲注：`gmx_main`是一个宏，其参数`temp`是一个函数名称，可以把`gmx_main`</span><br><span class="hljs-comment">/// 当作`main`函数。</span><br><span class="hljs-built_in">gmx_main</span>(temp)<br><span class="hljs-comment">///&gt;</span><br>&#123;<br><span class="hljs-comment">///&lt;讲注：实例化一个`Handle`对象，其参数`argc`与`argv`定义在宏`gmx_main`里面</span><br><span class="hljs-function">Handle <span class="hljs-title">hd</span><span class="hljs-params">(argc, argv)</span></span>;<br><span class="hljs-comment">///&gt;</span><br><br><span class="hljs-comment">///&lt;讲注：该后处理框架对体系的分析基于`Gromacs`中组(Group)的概念，即仅对用户</span><br><span class="hljs-comment">/// 选择的组进行分析，选择的组里面包含了该组中所有原子的序号。这里可以定义该程</span><br><span class="hljs-comment">/// 序所需组的个数，然后为每一个组定义一个变量方便后面代码操作。</span><br>hd.ngrps = <span class="hljs-number">1</span>; <span class="hljs-comment">// number of group(s);</span><br><span class="hljs-type">int</span> grp = <span class="hljs-number">0</span>;  <span class="hljs-comment">// selected group;</span><br><span class="hljs-comment">///&gt;</span><br><br><span class="hljs-comment">///&lt;讲注：在这里定义由命令行输入的参数，采用`Gromacs`自带参数解析系统，支持的变量类型有：</span><br><span class="hljs-comment">///      `int, int64, real, time, str, bool, rvec, enum` </span><br><span class="hljs-comment">///      详情可在`Gromacs`源代码文件`include/gromacs/commandline/pargs.h`中查看</span><br><span class="hljs-comment">///      注意：浮点数要用`real`类型，不能直接用`double`类型</span><br><span class="hljs-comment">/* add some user-defined pargs. here */</span><br><span class="hljs-type">int</span> nbin = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> dim = <span class="hljs-number">2</span>;     <span class="hljs-comment">// 0(x), 1(y), 2(z);</span><br>real lowPos = <span class="hljs-number">0</span>; <span class="hljs-comment">// nm;</span><br>real upPos = <span class="hljs-number">30</span>; <span class="hljs-comment">// nm;</span><br><br><span class="hljs-comment">/// 在这里编写命令行参数接口</span><br>hd.pa = &#123;<br>&#123; <span class="hljs-string">&quot;-nbin&quot;</span>, FALSE, etINT,  &#123;&amp;nbin&#125;, <span class="hljs-string">&quot;nbins.&quot;</span>&#125;,<br>&#123; <span class="hljs-string">&quot;-dim&quot;</span>, FALSE, etINT, &#123;&amp;dim&#125;, <span class="hljs-string">&quot;dim, 0(x), 1(y), 2(z)&quot;</span>&#125;,<br>&#123; <span class="hljs-string">&quot;-up&quot;</span>, FALSE, etREAL, &#123;&amp;upPos&#125;, <span class="hljs-string">&quot;up position of region of molecule/ion (nm)&quot;</span> &#125;,<br>&#123; <span class="hljs-string">&quot;-low&quot;</span>, FALSE, etREAL, &#123;&amp;lowPos&#125;, <span class="hljs-string">&quot;low position of region of molecule/ion (nm)&quot;</span> &#125;<br>&#125;;<br><br><span class="hljs-comment">/// 在这里定义后处理过程中涉及到的输入/输出文件名称</span><br>hd.fnm = &#123;<br>&#123; efXVG, <span class="hljs-string">&quot;-o&quot;</span>, <span class="hljs-string">&quot;analysisOutput&quot;</span>, ffWRITE &#125;<br>&#125;;<br><span class="hljs-comment">///&gt;</span><br><br><span class="hljs-comment">///&lt;讲注：初始化，在这个函数内会处理命令行选项，选择分析组，分析拓扑信息，并</span><br><span class="hljs-comment">/// 计算组内原子的电荷量与质量。</span><br><span class="hljs-comment">/// 注：该函数有一个可选参数，默认为`true`，代表选择的组内具有同种分子，否则</span><br><span class="hljs-comment">/// 为`false`。</span><br>hd.<span class="hljs-built_in">init</span>();<br><span class="hljs-comment">///&gt;</span><br><br><span class="hljs-comment">///&lt;讲注：读取第一帧轨迹数据。数据更新在`hd.fr`内。</span><br>hd.<span class="hljs-built_in">readFirstFrame</span>();<br><span class="hljs-comment">///&gt;</span><br><br><span class="hljs-comment">///&lt;讲注：`hd.initPos(grp)`与`hd.initPosc(grp)`两个函数初始化两个矩阵类</span><br><span class="hljs-comment">/// 型数据结构，分别储存分子中原子轨迹信息与分子中心轨迹信息。函数的参数为选</span><br><span class="hljs-comment">/// 择组的组号。</span><br><span class="hljs-comment">/// `hd.initPos(grp)`返回的数据大小为: [分子个数]x[每个分子中原子个数]x[3]</span><br><span class="hljs-comment">/// `hd.initPosc(grp)`返回的数据大小为: [分子个数]x[3]</span><br>hd.pos1 = hd.<span class="hljs-built_in">initPos</span>(grp);<br>hd.posc1 = hd.<span class="hljs-built_in">initPosc</span>(grp);<br><span class="hljs-comment">///&gt;</span><br><br><span class="hljs-comment">///&lt;讲注：`itp::vecd`为一种数组类型，数组中每个元素类型为`double`，数组</span><br><span class="hljs-comment">/// 长度为`nbin`。函数`fill`指向数组中填充相同的数值。</span><br><span class="hljs-comment">/// 相似的数据结构还有：</span><br><span class="hljs-comment">/// `itp::veci`: `int`型数组</span><br><span class="hljs-comment">/// `itp::vecd`: `double`型数组</span><br><span class="hljs-comment">/// `itp::mati`: `int`型矩阵</span><br><span class="hljs-comment">/// `itp::matd`: `double`型矩阵</span><br><span class="hljs-comment">/// `itp::boxd`: `double`型三维矩阵</span><br><span class="hljs-comment">/// 这些类型为C++开源矩阵库Eigen(https://eigen.tuxfamily.org)中类型的别名</span><br><span class="hljs-function">itp::vecd <span class="hljs-title">density</span><span class="hljs-params">(nbin)</span></span>;<br>density.<span class="hljs-built_in">fill</span>(<span class="hljs-number">0</span>);<br><span class="hljs-comment">///&gt;</span><br><br><span class="hljs-type">double</span> dbin = (upPos - lowPos) / nbin;<br><span class="hljs-type">int</span> me = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* ------------- main loop for each frame ----------------- */</span><br><span class="hljs-keyword">do</span><br>&#123;<br><span class="hljs-comment">///&lt;讲注：获取位置以及位置中心，并储存在相应的数据结构中，</span><br><span class="hljs-comment">/// `loadPositionCenter`还有第三个可选参数，默认为0（代表取质量中心）</span><br><span class="hljs-comment">/// 还有1（代表几何中心）和2（代表电荷中心）</span><br>hd.<span class="hljs-built_in">loadPosition</span>(hd.pos1, grp);<br>hd.<span class="hljs-built_in">loadPositionCenter</span>(hd.posc1, grp);<br><span class="hljs-comment">///&gt;</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; hd.nmol[grp]; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (lowPos &lt;= hd.<span class="hljs-built_in">posc1</span>(i, dim) &amp;&amp; hd.<span class="hljs-built_in">posc1</span>(i, dim) &lt; upPos)<br>&#123;<br>me = (hd.<span class="hljs-built_in">posc1</span>(i, dim) - lowPos) / dbin;<br>density[me]++;<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">while</span> (hd.<span class="hljs-built_in">readNextFrame</span>());<br><span class="hljs-comment">/* --------------- main loop end -------------------- */</span><br><br>density /= hd.nframe;<br><br><span class="hljs-comment">/* ------------- for output ---------------*/</span><br><span class="hljs-comment">///&lt;讲注：打开一个文件，文件名由命令行参数&quot;-o&quot;决定</span><br><span class="hljs-comment">/// `openWrite`函数还有第二个可选参数，默认为`true`，代表在文件开始处写入</span><br><span class="hljs-comment">/// 文件生成的相关信息（如路径、创建时间、命令行参数等）</span><br><span class="hljs-keyword">auto</span> ofile = hd.<span class="hljs-built_in">openWrite</span>(hd.<span class="hljs-built_in">get_opt2fn</span>(<span class="hljs-string">&quot;-o&quot;</span>));<br><span class="hljs-comment">///&gt;</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nbin; i++)<br>&#123;<br><span class="hljs-comment">///&lt;讲注：输出数据到文件。这里输出操作采用的是一个</span><br><span class="hljs-comment">/// 开源库&#123;fmt&#125;(https://github.com/fmtlib/fmt)</span><br>fmt::<span class="hljs-built_in">print</span>(ofile, <span class="hljs-string">&quot;&#123;:8.5f&#125; &#123;10.5f&#125;\n&quot;</span>, lowPos + dbin / <span class="hljs-number">2</span> + dbin*i, density[i]);<br><span class="hljs-comment">///&gt;</span><br>&#125;<br><span class="hljs-built_in">fclose</span>(ofile);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上程序统计指定范围内（<code>-low</code>与<code>-up</code>之间）、指定维度（<code>-dim</code>）分子的个数分布。</p><h2 id="转"><a href="#转" class="headerlink" title="转"></a>转</h2><ul><li><p>class <code>itp::GmxHandle</code></p><p>位于命名空间<code>itp</code>下的类<code>GmxHandle</code>里面定义了绝大多数在轨迹分析过程中会用到的数据以及函数，比如体系的拓扑结构、分子与原子的数目、分子的质量与电量等数据结构，获取分子位置、速度、受力等函数</p><ul><li>数据成员<ul><li><p><strong>desc</strong>  (std::vector&lt;const char*&gt;)</p><p>  描述本程序用途的字符串</p></li><li><p><strong>Lbox</strong>  (double[3])</p><p>  模拟盒子的长度，每当采用loadPosition等函数读取轨迹都会更新</p></li><li><p><strong>grpname</strong>  (char**)</p><p>  选择组的名称</p></li><li><p><strong>ngx</strong>      (int*)</p><p>  选择组的中含有多少原子</p></li><li><p><strong>top</strong>      (t_topology*)</p><p>  拓扑信息。里面包含所有拓扑信息</p></li><li><p><strong>ir</strong>       (t_inputrec*)</p><p>  输入参数，包含mdp文件中所有信息</p></li><li><p><strong>dt</strong>       (double)</p><p>  模拟时间步长，ps</p></li><li><p><strong>time</strong>     (double)</p><p>  模拟的时刻</p></li><li><p><strong>preTime</strong>  (double)</p><p>  模拟的上一步时刻</p></li><li><p><strong>index</strong>    (int**)</p><p>  原子索引，包含选择的每一组中的原子序号</p></li><li><p><strong>fr</strong>       (t_trxframe*)</p><p>  轨迹相关信息</p></li><li><p><strong>flags</strong>    (int)</p><p>  flags，控制是否读取位置、速度或力，默认为（TRX_READ_X）</p></li><li><p><strong>ngrps</strong>    (int)</p><p>  选择的组的数目，默认为1</p></li><li><p><strong>nframe</strong>   (int)</p><p>  读取到的轨迹总帧数</p></li><li><p><strong>pa</strong>       (std::vector<t_pargs>)</t_pargs></p><p>  储存命令行参数</p></li><li><p><strong>fnm</strong>      (std::vector<t_filenm>)</t_filenm></p><p>  储存命令行文件输入&#x2F;输出</p></li><li><p><strong>napm</strong>     (veci)</p><p>  在选择的组中分子中包含的原子数</p></li><li><p><strong>nmol</strong>     (veci)</p><p>  在选择的组中的分子数</p></li><li><p><strong>mass</strong>     (Vec<vecd>)</vecd></p><p>  在选择的组中一个分子中每个原子的质量</p></li><li><p><strong>charge</strong>   (Vec<vecd>)</vecd></p><p>  在选择的组中一个分子中每个原子的电荷量</p></li></ul></li><li>成员函数<ul><li><p><code>GmxHandle(int argc, char** argv)</code></p><p>  构造函数</p><p>  参数：<code>argc</code>与<code>argv</code>为<code>main()</code>函数的参数</p></li><li><p><code>void init(bool bFullMolecule=true)</code></p><p>  初始化，在这个函数内会处理命令行选项，选择分析组，分析拓扑信息，并计算组内原子的电荷量与质量。</p><p>  注：可选参数<code>bFullMolecule</code>，默认为<code>true</code>，代表选择的组内具有同种分子，否则为<code>false</code>。</p></li><li><p><code>bool readFirstFrame()</code></p><p>  读取第一帧轨迹数据，</p><p>  返回：是否读取成功</p></li><li><p><code>bool readNextFrame()</code></p><p>  读取下一帧轨迹数据</p><p>  返回：是否读取成功</p></li><li><p><code>boxd initPos(int grp)</code></p><p>  初始化一个空的可以储存分子位置信息的数据结构</p><p>  参数：<code>grp</code>为组号</p></li><li><p><code>matd initPosc(int grp)</code></p><p>  初始化一个空的可以储存分子中心位置的结构</p><p>  参数：<code>grp</code>为组号</p></li><li><p><code>void loadPosition(boxd&amp; pos, int grp)</code></p><p>  读取位置信息，并储存到结构<code>pos</code>中，<code>grp</code>为组号</p></li><li><p><code>void loadPositionCenter(matd&amp; posc, int grp, int com=0)</code></p><p>  读取位置中心信息，并储存到结构<code>pos</code>中，<code>grp</code>为组号</p></li><li><p><code>void loadVelocity(boxd&amp; vel, int grp)</code></p><p>  读取速度信息，并储存到结构<code>vel</code>中，<code>grp</code>为组号</p></li><li><p><code>void loadVelocityCenter(matd&amp; velc, int grp)</code></p><p>  读取速度中心信息，并储存到结构<code>velc</code>中，<code>grp</code>为组号</p></li><li><p><code>void loadForce(boxd&amp; force, int grp)</code></p><p>  读取力信息，并储存到结构<code>force</code>中，<code>grp</code>为组号</p></li><li><p><code>void loadForceCenter(matd&amp; forcec, int grp)</code></p><p>  读取力中心信息，并储存到结构<code>forcec</code>中，<code>grp</code>为组号</p></li><li><p><code>void loadLJParameter(int grp1, int grp2, matd&amp; c6, matd&amp; c12)</code></p><p>  读取LJ参数信息，储存到<code>c6</code>和<code>c12</code>中，两组组号分别为<code>grp1</code>和<code>grp2</code></p></li><li><p><code>FILE* openWrite(std::string fnm, bool writeInfo=true)</code></p><p>  讲注：打开一个文件</p><p>  参数：</p><p>  <code>fnm</code>：文件名</p><p>  <code>writeInfo</code>： 可选参数，默认为<code>true</code>，代表在文件开始处写入文件生成的相关信息（如路径、创建时间、命令行参数等）</p></li><li><p><code>const char* get_ftp2fn(int ftp)</code></p><p>  通过命令行参数类型获取文件名称</p><p>  参数：</p><p>  <code>ftp</code>：命令行参数类型，有<code>efXVG</code>、<code>efNDX</code>、<code>efTPR</code>、<code>efNDX</code>等值可选，可在文件<code>include/gromacs/fileio/filetypes.h</code>中查看完整可选范围。</p></li><li><p><code>const char* get_ftp2fn_null(int ftp)</code></p><p>  同上</p></li><li><p><code>const char* get_opt2fn(const char* opt)</code></p><p>  通过命令行选项获取文件名称</p><p>  参数：</p><p>  <code>opt</code>：命令行文件输入&#x2F;输出选项</p></li><li><p><code>static double periodicity(double dx, double box)</code></p><p>  静态成员函数，处理周期性问题</p><p>  参数：</p><p>  <code>dx</code>：两位置之差</p><p>  <code>box</code>：在计算<code>dx</code>维度上的盒子长度</p></li></ul></li></ul></li><li><p>此后处理框架中用到的外部开源库</p><ul><li><p><a href="https://eigen.tuxfamily.org/">Eigen</a></p><p>  一个开源的线性代数库，里面有方便使用的矩阵、向量等类型用法参照<a href="https://ting2938.github.io/2020/07/18/Eigen%E4%B8%8EMatlab%E6%93%8D%E4%BD%9C%E5%AF%B9%E7%85%A7">Eigen与Matlab操作对照</a></p><p>  在本框架中常用的数据结构有：</p><p>  <code>itp::veci</code>: <code>int</code>型数组</p><p>  <code>itp::vecd</code>: <code>double</code>型数组</p><p>  <code>itp::mati</code>: <code>int</code>型矩阵</p><p>  <code>itp::matd</code>: <code>double</code>型矩阵</p><p>  <code>itp::boxd</code>: <code>double</code>型三维矩阵</p></li><li><p><a href="https://github.com/fmtlib/fmt">fmt</a></p><p>  一个开源的C++输出格式控制库，用法类似<code>Python</code>的格式化字符串方式，如</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 输出到终端</span><br>fmt::<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello &#123;&#125;!\n&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>fmt::<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;4.2 + 2.1 = &#123;:5.2f&#125;&quot;</span>, <span class="hljs-number">6.3</span>);<br><br><span class="hljs-comment">// 输出到文件</span><br><span class="hljs-function">FILE* <span class="hljs-title">ofile</span><span class="hljs-params">(<span class="hljs-string">&quot;output.dat&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>)</span></span>;<br>fmt::<span class="hljs-built_in">print</span>(ofile, <span class="hljs-string">&quot;Hello &#123;&#125;!\n&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br><span class="hljs-function">std::ofstream <span class="hljs-title">ofsfile</span><span class="hljs-params">(<span class="hljs-string">&quot;output.dat&quot;</span>)</span></span>;<br>fmt::<span class="hljs-built_in">print</span>(ofsfile, <span class="hljs-string">&quot;Hello &#123;&#125;!\n&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="合"><a href="#合" class="headerlink" title="合"></a>合</h2><p>运用本框架进行Gromacs后处理分析过程中遇到问题可以联系我</p><blockquote><p>Name : 叶挺</p><p>Email: <a href="mailto:&#x79;&#101;&#116;&#105;&#x6e;&#103;&#x32;&#57;&#x33;&#56;&#64;&#104;&#117;&#x73;&#x74;&#46;&#101;&#100;&#x75;&#x2e;&#99;&#110;">&#x79;&#101;&#116;&#105;&#x6e;&#103;&#x32;&#57;&#x33;&#56;&#64;&#104;&#117;&#x73;&#x74;&#46;&#101;&#100;&#x75;&#x2e;&#99;&#110;</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Gromacs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用命令（持续更新中...）</title>
    <link href="/2020/11/17/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0-%EF%BC%89/"/>
    <url>/2020/11/17/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0-%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="find"><a href="#find" class="headerlink" title="find"></a><code>find</code></h2><ul><li><code>find . -type f -size +1G</code><ul><li>查找大于1G的所有文件（或+10M，为大于10M的文件）</li></ul></li></ul><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a><code>grep</code></h2><ul><li><code>grep -v cpp$</code><ul><li><code>-v</code> 代表反向选取，即选择不以<code>cpp</code>结尾的行 </li><li><code>egrep -v &quot;trr|edr|xvg|[0-9]$&quot;</code> 反向选取多个字段，采用<code>egrep</code>(即正则表达式的版本)</li></ul></li><li><code>echo &quot;Modify: 2020-11-24 11:09:22.584500109 +0800&quot; | grep -oP &quot;\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;&quot;</code><ul><li>输出：2020-11-24</li><li><code>-o</code>代表只输出匹配的部分</li></ul></li></ul><h2 id="du"><a href="#du" class="headerlink" title="du"></a><code>du</code></h2><p><code>du</code>统计文件以及文件夹大小</p><ul><li><code>du -sh</code><ul><li>统计当前文件占用大小</li></ul></li><li><code>du -d 1 -h</code><ul><li><code>-d 1</code> 代表统计文件夹深度为1</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建Git服务器</title>
    <link href="/2020/11/12/%E6%90%AD%E5%BB%BAGit%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2020/11/12/%E6%90%AD%E5%BB%BAGit%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p><a href="https://git-scm.com/">Git</a>是一种版本控制的开源软件，由Linux之父Linus开发的。它是一种分布式版本控制系统，不需要服务器软件就可以进行版本控制，这使得源代码的发布以及多人协作时交流十分便捷，Git软件普遍预装在Linux各个发行版中，查看系统中的Git版本号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git --version<br>git version 1.7.1<br></code></pre></td></tr></table></figure><h2 id="搭建远程Git服务器"><a href="#搭建远程Git服务器" class="headerlink" title="搭建远程Git服务器"></a>搭建远程Git服务器</h2><p>搭建远程Git服务器的要求很低，只需要本地机器能通过ssh访问远程服务器</p><p>创建过程特别简单，首先在<strong>远程服务器</strong>中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkdir</span> -p ~/gitServer <span class="hljs-comment"># 创建一个目录来作为代码仓库</span><br>$ <span class="hljs-built_in">cd</span> ~/gitServer<br>$ git init <span class="hljs-comment"># 创建一个空的git仓库</span><br>$ git config receive.denyCurrentBranch ignore<br></code></pre></td></tr></table></figure><p>至此远程Git服务器搭建<strong>完成</strong></p><h2 id="在本地机器上进行源代码管理"><a href="#在本地机器上进行源代码管理" class="headerlink" title="在本地机器上进行源代码管理"></a>在本地机器上进行源代码管理</h2><ul><li><p>首先，在本地<code>clone</code>远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkdir</span> user1<br>$ <span class="hljs-built_in">cd</span> user1<br>$ git <span class="hljs-built_in">clone</span> ssh://&lt;user&gt;@&lt;ip&gt;:&lt;port&gt;/path/to/.git  <span class="hljs-comment"># clone远程仓库到本地</span><br>$ <span class="hljs-built_in">cd</span> gitServer<br>$ <span class="hljs-built_in">ls</span> -a <span class="hljs-comment"># 会有一个.git的隐藏文件夹</span><br>.  ..  .git <br></code></pre></td></tr></table></figure></li><li><p>推送本地代码到远程服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">touch</span> readme.md <span class="hljs-comment"># 创建一个文件</span><br>$ git add . <span class="hljs-comment"># 添加要推送的文件</span><br>$ git commit -m <span class="hljs-string">&quot;First push&quot;</span> <span class="hljs-comment"># 添加推送信息</span><br>$ git push <span class="hljs-comment"># 推送文件到远程服务器</span><br></code></pre></td></tr></table></figure></li><li><p>远程服务器上看更新的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git reset --hard<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>化学中常用能量单位换算</title>
    <link href="/2020/10/26/%E5%8C%96%E5%AD%A6%E4%B8%AD%E5%B8%B8%E7%94%A8%E8%83%BD%E9%87%8F%E5%8D%95%E4%BD%8D%E6%8D%A2%E7%AE%97/"/>
    <url>/2020/10/26/%E5%8C%96%E5%AD%A6%E4%B8%AD%E5%B8%B8%E7%94%A8%E8%83%BD%E9%87%8F%E5%8D%95%E4%BD%8D%E6%8D%A2%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="量化常用单位和换算因子"><a href="#量化常用单位和换算因子" class="headerlink" title="量化常用单位和换算因子"></a>量化常用单位和换算因子</h1><h2 id="1-原子单位"><a href="#1-原子单位" class="headerlink" title="1. 原子单位"></a>1. 原子单位</h2><p>原子单位（a.u.）定义为：电子质量$m_e$&#x3D;电子电荷$e$&#x3D;Bohr半径$a_0 &#x3D; 1$<br>在该单位制中，Planck常数$h&#x3D;2\pi$，于是$\hbar &#x3D; 1$。真空介电常数$1&#x2F;4\pi\epsilon_0 &#x3D; 1$。真空光速$c &#x3D; \alpha^{-1} &#x3D; 137.036$，其中$\alpha$为精细结构常数。</p><script>function calc(form, name){    var rate = [1, 2.997925E4, 1.986447E-5, 1.239842E-4, 4.556335E-6, 1.196266E-2, 2.85914E-3, 1.438769];    var index = 0;    for (var i = 0; i < rate.length; i++)    {        if (form.elements[i].name == name)        {            index = i;            break;        }    }    var thisValue = form.elements[index].value;    for (var i = 0; i < rate.length; i++)    {        form.elements[i].value = thisValue / rate[index] * rate[i];    }}</script><h2 id="2-常见能量单位转换计算器"><a href="#2-常见能量单位转换计算器" class="headerlink" title="2. 常见能量单位转换计算器"></a>2. 常见能量单位转换计算器</h2><form><input type="text" name="cm1" value="0" onchange="calc(this.form, this.name)"> cm<sup>-1 <br><input type="text" name="MHz" value="0" onchange="calc(this.form, this.name)"> MHz <br><input type="text" name="aJ" value="0" onchange="calc(this.form, this.name)"> aJ <br><input type="text" name="eV" value="0" onchange="calc(this.form, this.name)"> eV <br><input type="text" name="Hartree" value="0" onchange="calc(this.form, this.name)"> Hartree <br><input type="text" name="kJ/mol" value="0" onchange="calc(this.form, this.name)"> kJ/mol <br><input type="text" name="kcal/mol" value="0" onchange="calc(this.form, this.name)"> kcal/mol <br><input type="text" name="K" value="0" onchange="calc(this.form, this.name)"> K <br></sup></form><h2 id="3-其他能量单位转换"><a href="#3-其他能量单位转换" class="headerlink" title="3. 其他能量单位转换"></a>3. 其他能量单位转换</h2><p>$$ 1 kcal&#x2F;mol &#x3D; 6.948 \times 10^{-14} erg  $$</p><p>$$ 1 eV &#x3D; 1.602 \times 10^{-12} erg $$ </p><p>$$ 1 Hartree &#x3D; 4.36 \times 10^{-11} erg &#x3D; 2 Rydberg $$ </p><p>$$ 1 erg &#x3D; 1.439 \times 10^{13} kcal&#x2F;mol &#x3D; 6.2415 \times 10^{11} eV &#x3D; 2.2937 \times 10^{10} Hartree &#x3D; 5.034 \times 10^{15} cm^{-1} $$</p><blockquote><p>ref: <a href="http://qchem.pw/data/units.html">http://qchem.pw/data/units.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Research</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>干货！Matlab+AI打造高质量论文图片</title>
    <link href="/2020/10/15/%E5%B9%B2%E8%B4%A7%EF%BC%81Matlab-AI%E6%89%93%E9%80%A0%E9%AB%98%E8%B4%A8%E9%87%8F%E8%AE%BA%E6%96%87%E5%9B%BE%E7%89%87/"/>
    <url>/2020/10/15/%E5%B9%B2%E8%B4%A7%EF%BC%81Matlab-AI%E6%89%93%E9%80%A0%E9%AB%98%E8%B4%A8%E9%87%8F%E8%AE%BA%E6%96%87%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h2 id="如何生成高质量论文矢量图"><a href="#如何生成高质量论文矢量图" class="headerlink" title="如何生成高质量论文矢量图"></a>如何生成高质量论文矢量图</h2><h3 id="1-在Matlab中指定图片大小，字体大小，并导出为svg格式的矢量图"><a href="#1-在Matlab中指定图片大小，字体大小，并导出为svg格式的矢量图" class="headerlink" title="1. 在Matlab中指定图片大小，字体大小，并导出为svg格式的矢量图"></a>1. 在Matlab中指定图片大小，字体大小，并导出为<code>svg</code>格式的矢量图</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs matlab">x = <span class="hljs-built_in">linspace</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>);<br>y1 = <span class="hljs-built_in">sin</span>(x);<br>y2 = <span class="hljs-built_in">cos</span>(x);<br><br><span class="hljs-comment">% 图片大小为 10cm X 8cm</span><br>fig = <span class="hljs-built_in">figure</span>(<span class="hljs-string">&#x27;Position&#x27;</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">8</span>], <span class="hljs-string">&#x27;Units&#x27;</span>, <span class="hljs-string">&#x27;centimeters&#x27;</span>); <br><br><span class="hljs-built_in">plot</span>(x, y1, <span class="hljs-string">&#x27;DisplayName&#x27;</span>, <span class="hljs-string">&#x27;sin&#x27;</span>)<br><span class="hljs-built_in">hold</span> on<br><span class="hljs-built_in">plot</span>(x, y2, <span class="hljs-string">&#x27;DisplayName&#x27;</span>, <span class="hljs-string">&#x27;cos&#x27;</span>)<br><br>ylim([<span class="hljs-number">0</span>, <span class="hljs-number">1.5</span>])<br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;Location&#x27;</span>, <span class="hljs-string">&#x27;north&#x27;</span>);<br><br>print(fig, <span class="hljs-string">&#x27;sincos.svg&#x27;</span>, <span class="hljs-string">&#x27;-r300&#x27;</span>, <span class="hljs-string">&#x27;-dsvg&#x27;</span>); <span class="hljs-comment">% 输出为 svg 格式</span><br></code></pre></td></tr></table></figure><p><img src="/2020/10/15/%E5%B9%B2%E8%B4%A7%EF%BC%81Matlab-AI%E6%89%93%E9%80%A0%E9%AB%98%E8%B4%A8%E9%87%8F%E8%AE%BA%E6%96%87%E5%9B%BE%E7%89%87/2023-04-03-21-16-49.png"></p><h3 id="2-打开AI-Adobe-illustrator-，新建，设置图纸大小（16cm-X-10cm）"><a href="#2-打开AI-Adobe-illustrator-，新建，设置图纸大小（16cm-X-10cm）" class="headerlink" title="2. 打开AI (Adobe illustrator)，新建，设置图纸大小（16cm X 10cm）"></a>2. 打开AI (Adobe illustrator)，新建，设置图纸大小（16cm X 10cm）</h3><h3 id="3-插入Matlab导出的svg文件（文件-gt-置入，快捷键为Ctrl-Shift-P）"><a href="#3-插入Matlab导出的svg文件（文件-gt-置入，快捷键为Ctrl-Shift-P）" class="headerlink" title="3. 插入Matlab导出的svg文件（文件-&gt;置入，快捷键为Ctrl+Shift+P）"></a>3. 插入Matlab导出的<code>svg</code>文件（<code>文件</code>-&gt;<code>置入</code>，快捷键为<code>Ctrl+Shift+P</code>）</h3><h3 id="4-调整图片大小"><a href="#4-调整图片大小" class="headerlink" title="4. 调整图片大小"></a>4. 调整图片大小</h3><p>   插入到AI中的图片可能会很大，这时就要对图片进行缩放，可以用鼠标进行缩放，如果要保证横纵缩放比例一致，需要按住<code>Shift</code>键。用鼠标缩放可能会导致字体大小不一致，这时需要输入具体数值改变图片大小，输入的数值需要与Matlab中设定的图片大小一致，可能缩放过后线条的粗细没变，这时需要设置<code>缩放描边和效果</code></p><p>   <img src="/2020/10/15/%E5%B9%B2%E8%B4%A7%EF%BC%81Matlab-AI%E6%89%93%E9%80%A0%E9%AB%98%E8%B4%A8%E9%87%8F%E8%AE%BA%E6%96%87%E5%9B%BE%E7%89%87/2023-04-03-21-17-14.png"></p><p>   <img src="/2020/10/15/%E5%B9%B2%E8%B4%A7%EF%BC%81Matlab-AI%E6%89%93%E9%80%A0%E9%AB%98%E8%B4%A8%E9%87%8F%E8%AE%BA%E6%96%87%E5%9B%BE%E7%89%87/2023-04-03-21-17-30.png"></p><h3 id="5-从AI中输出高质量矢量图"><a href="#5-从AI中输出高质量矢量图" class="headerlink" title="5. 从AI中输出高质量矢量图"></a>5. 从AI中输出高质量矢量图</h3><p>文件-&gt;存储为，可以保存为<code>pdf</code>或<code>eps</code>等矢量图格式</p><p><img src="/2020/10/15/%E5%B9%B2%E8%B4%A7%EF%BC%81Matlab-AI%E6%89%93%E9%80%A0%E9%AB%98%E8%B4%A8%E9%87%8F%E8%AE%BA%E6%96%87%E5%9B%BE%E7%89%87/2023-04-03-21-17-57.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Matlab</tag>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Eigen与Matlab操作对照</title>
    <link href="/2020/07/18/Eigen%E4%B8%8EMatlab%E6%93%8D%E4%BD%9C%E5%AF%B9%E7%85%A7/"/>
    <url>/2020/07/18/Eigen%E4%B8%8EMatlab%E6%93%8D%E4%BD%9C%E5%AF%B9%E7%85%A7/</url>
    
    <content type="html"><![CDATA[<p><a href="https://eigen.tuxfamily.org/dox/AsciiQuickReference.txt">https://eigen.tuxfamily.org/dox/AsciiQuickReference.txt</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// A simple quickref for Eigen. Add anything that&#x27;s missing.</span><br><span class="hljs-comment">// Main author: Keir Mierle</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Eigen/Dense&gt;</span></span><br><br>Matrix&lt;<span class="hljs-type">double</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>&gt; A;               <span class="hljs-comment">// Fixed rows and cols. Same as Matrix3d.</span><br>Matrix&lt;<span class="hljs-type">double</span>, <span class="hljs-number">3</span>, Dynamic&gt; B;         <span class="hljs-comment">// Fixed rows, dynamic cols.</span><br>Matrix&lt;<span class="hljs-type">double</span>, Dynamic, Dynamic&gt; C;   <span class="hljs-comment">// Full dynamic. Same as MatrixXd.</span><br>Matrix&lt;<span class="hljs-type">double</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, RowMajor&gt; E;     <span class="hljs-comment">// Row major; default is column-major.</span><br>Matrix3f P, Q, R;                     <span class="hljs-comment">// 3x3 float matrix.</span><br>Vector3f x, y, z;                     <span class="hljs-comment">// 3x1 float matrix.</span><br>RowVector3f a, b, c;                  <span class="hljs-comment">// 1x3 float matrix.</span><br>VectorXd v;                           <span class="hljs-comment">// Dynamic column vector of doubles</span><br><span class="hljs-type">double</span> s;                            <br><br><span class="hljs-comment">// Basic usage</span><br><span class="hljs-comment">// Eigen          // Matlab           // comments</span><br>x.<span class="hljs-built_in">size</span>()          <span class="hljs-comment">// length(x)        // vector size</span><br>C.<span class="hljs-built_in">rows</span>()          <span class="hljs-comment">// size(C,1)        // number of rows</span><br>C.<span class="hljs-built_in">cols</span>()          <span class="hljs-comment">// size(C,2)        // number of columns</span><br><span class="hljs-built_in">x</span>(i)              <span class="hljs-comment">// x(i+1)           // Matlab is 1-based</span><br><span class="hljs-built_in">C</span>(i,j)            <span class="hljs-comment">// C(i+1,j+1)       //</span><br><br>A.<span class="hljs-built_in">resize</span>(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>);   <span class="hljs-comment">// Runtime error if assertions are on.</span><br>B.<span class="hljs-built_in">resize</span>(<span class="hljs-number">4</span>, <span class="hljs-number">9</span>);   <span class="hljs-comment">// Runtime error if assertions are on.</span><br>A.<span class="hljs-built_in">resize</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);   <span class="hljs-comment">// Ok; size didn&#x27;t change.</span><br>B.<span class="hljs-built_in">resize</span>(<span class="hljs-number">3</span>, <span class="hljs-number">9</span>);   <span class="hljs-comment">// Ok; only dynamic cols changed.</span><br>                  <br>A &lt;&lt; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>,     <span class="hljs-comment">// Initialize A. The elements can also be</span><br>     <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>,     <span class="hljs-comment">// matrices, which are stacked along cols</span><br>     <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>;     <span class="hljs-comment">// and then the rows are stacked.</span><br>B &lt;&lt; A, A, A;     <span class="hljs-comment">// B is three horizontally stacked A&#x27;s.</span><br>A.<span class="hljs-built_in">fill</span>(<span class="hljs-number">10</span>);       <span class="hljs-comment">// Fill A with all 10&#x27;s.</span><br><br><span class="hljs-comment">// Eigen                                    // Matlab</span><br>MatrixXd::<span class="hljs-built_in">Identity</span>(rows,cols)               <span class="hljs-comment">// eye(rows,cols)</span><br>C.<span class="hljs-built_in">setIdentity</span>(rows,cols)                    <span class="hljs-comment">// C = eye(rows,cols)</span><br>MatrixXd::<span class="hljs-built_in">Zero</span>(rows,cols)                   <span class="hljs-comment">// zeros(rows,cols)</span><br>C.<span class="hljs-built_in">setZero</span>(rows,cols)                        <span class="hljs-comment">// C = zeros(rows,cols)</span><br>MatrixXd::<span class="hljs-built_in">Ones</span>(rows,cols)                   <span class="hljs-comment">// ones(rows,cols)</span><br>C.<span class="hljs-built_in">setOnes</span>(rows,cols)                        <span class="hljs-comment">// C = ones(rows,cols)</span><br>MatrixXd::<span class="hljs-built_in">Random</span>(rows,cols)                 <span class="hljs-comment">// rand(rows,cols)*2-1            // MatrixXd::Random returns uniform random numbers in (-1, 1).</span><br>C.<span class="hljs-built_in">setRandom</span>(rows,cols)                      <span class="hljs-comment">// C = rand(rows,cols)*2-1</span><br>VectorXd::<span class="hljs-built_in">LinSpaced</span>(size,low,high)          <span class="hljs-comment">// linspace(low,high,size)&#x27;</span><br>v.<span class="hljs-built_in">setLinSpaced</span>(size,low,high)               <span class="hljs-comment">// v = linspace(low,high,size)&#x27;</span><br>VectorXi::<span class="hljs-built_in">LinSpaced</span>(((hi-low)/step)+<span class="hljs-number">1</span>,      <span class="hljs-comment">// low:step:hi</span><br>                    low,low+step*(size<span class="hljs-number">-1</span>))  <span class="hljs-comment">//</span><br><br><br><span class="hljs-comment">// Matrix slicing and blocks. All expressions listed here are read/write.</span><br><span class="hljs-comment">// Templated size versions are faster. Note that Matlab is 1-based (a size N</span><br><span class="hljs-comment">// vector is x(1)...x(N)).</span><br><span class="hljs-comment">// Eigen                           // Matlab</span><br>x.<span class="hljs-built_in">head</span>(n)                          <span class="hljs-comment">// x(1:n)</span><br>x.<span class="hljs-built_in">head</span>&lt;n&gt;()                        <span class="hljs-comment">// x(1:n)</span><br>x.<span class="hljs-built_in">tail</span>(n)                          <span class="hljs-comment">// x(end - n + 1: end)</span><br>x.<span class="hljs-built_in">tail</span>&lt;n&gt;()                        <span class="hljs-comment">// x(end - n + 1: end)</span><br>x.<span class="hljs-built_in">segment</span>(i, n)                    <span class="hljs-comment">// x(i+1 : i+n)</span><br>x.<span class="hljs-built_in">segment</span>&lt;n&gt;(i)                    <span class="hljs-comment">// x(i+1 : i+n)</span><br>P.<span class="hljs-built_in">block</span>(i, j, rows, cols)          <span class="hljs-comment">// P(i+1 : i+rows, j+1 : j+cols)</span><br>P.<span class="hljs-built_in">block</span>&lt;rows, cols&gt;(i, j)          <span class="hljs-comment">// P(i+1 : i+rows, j+1 : j+cols)</span><br>P.<span class="hljs-built_in">row</span>(i)                           <span class="hljs-comment">// P(i+1, :)</span><br>P.<span class="hljs-built_in">col</span>(j)                           <span class="hljs-comment">// P(:, j+1)</span><br>P.<span class="hljs-built_in">leftCols</span>&lt;cols&gt;()                 <span class="hljs-comment">// P(:, 1:cols)</span><br>P.<span class="hljs-built_in">leftCols</span>(cols)                   <span class="hljs-comment">// P(:, 1:cols)</span><br>P.<span class="hljs-built_in">middleCols</span>&lt;cols&gt;(j)              <span class="hljs-comment">// P(:, j+1:j+cols)</span><br>P.<span class="hljs-built_in">middleCols</span>(j, cols)              <span class="hljs-comment">// P(:, j+1:j+cols)</span><br>P.<span class="hljs-built_in">rightCols</span>&lt;cols&gt;()                <span class="hljs-comment">// P(:, end-cols+1:end)</span><br>P.<span class="hljs-built_in">rightCols</span>(cols)                  <span class="hljs-comment">// P(:, end-cols+1:end)</span><br>P.<span class="hljs-built_in">topRows</span>&lt;rows&gt;()                  <span class="hljs-comment">// P(1:rows, :)</span><br>P.<span class="hljs-built_in">topRows</span>(rows)                    <span class="hljs-comment">// P(1:rows, :)</span><br>P.<span class="hljs-built_in">middleRows</span>&lt;rows&gt;(i)              <span class="hljs-comment">// P(i+1:i+rows, :)</span><br>P.<span class="hljs-built_in">middleRows</span>(i, rows)              <span class="hljs-comment">// P(i+1:i+rows, :)</span><br>P.<span class="hljs-built_in">bottomRows</span>&lt;rows&gt;()               <span class="hljs-comment">// P(end-rows+1:end, :)</span><br>P.<span class="hljs-built_in">bottomRows</span>(rows)                 <span class="hljs-comment">// P(end-rows+1:end, :)</span><br>P.<span class="hljs-built_in">topLeftCorner</span>(rows, cols)        <span class="hljs-comment">// P(1:rows, 1:cols)</span><br>P.<span class="hljs-built_in">topRightCorner</span>(rows, cols)       <span class="hljs-comment">// P(1:rows, end-cols+1:end)</span><br>P.<span class="hljs-built_in">bottomLeftCorner</span>(rows, cols)     <span class="hljs-comment">// P(end-rows+1:end, 1:cols)</span><br>P.<span class="hljs-built_in">bottomRightCorner</span>(rows, cols)    <span class="hljs-comment">// P(end-rows+1:end, end-cols+1:end)</span><br>P.<span class="hljs-built_in">topLeftCorner</span>&lt;rows,cols&gt;()       <span class="hljs-comment">// P(1:rows, 1:cols)</span><br>P.<span class="hljs-built_in">topRightCorner</span>&lt;rows,cols&gt;()      <span class="hljs-comment">// P(1:rows, end-cols+1:end)</span><br>P.<span class="hljs-built_in">bottomLeftCorner</span>&lt;rows,cols&gt;()    <span class="hljs-comment">// P(end-rows+1:end, 1:cols)</span><br>P.<span class="hljs-built_in">bottomRightCorner</span>&lt;rows,cols&gt;()   <span class="hljs-comment">// P(end-rows+1:end, end-cols+1:end)</span><br><br><span class="hljs-comment">// Of particular note is Eigen&#x27;s swap function which is highly optimized.</span><br><span class="hljs-comment">// Eigen                           // Matlab</span><br>R.<span class="hljs-built_in">row</span>(i) = P.<span class="hljs-built_in">col</span>(j);               <span class="hljs-comment">// R(i, :) = P(:, j)</span><br>R.<span class="hljs-built_in">col</span>(j1).<span class="hljs-built_in">swap</span>(mat1.<span class="hljs-built_in">col</span>(j2));      <span class="hljs-comment">// R(:, [j1 j2]) = R(:, [j2, j1])</span><br><br><span class="hljs-comment">// Views, transpose, etc;</span><br><span class="hljs-comment">// Eigen                           // Matlab</span><br>R.<span class="hljs-built_in">adjoint</span>()                        <span class="hljs-comment">// R&#x27;</span><br>R.<span class="hljs-built_in">transpose</span>()                      <span class="hljs-comment">// R.&#x27; or conj(R&#x27;)       // Read-write</span><br>R.<span class="hljs-built_in">diagonal</span>()                       <span class="hljs-comment">// diag(R)               // Read-write</span><br>x.<span class="hljs-built_in">asDiagonal</span>()                     <span class="hljs-comment">// diag(x)</span><br>R.<span class="hljs-built_in">transpose</span>().<span class="hljs-built_in">colwise</span>().<span class="hljs-built_in">reverse</span>()  <span class="hljs-comment">// rot90(R)              // Read-write</span><br>R.<span class="hljs-built_in">rowwise</span>().<span class="hljs-built_in">reverse</span>()              <span class="hljs-comment">// fliplr(R)</span><br>R.<span class="hljs-built_in">colwise</span>().<span class="hljs-built_in">reverse</span>()              <span class="hljs-comment">// flipud(R)</span><br>R.<span class="hljs-built_in">replicate</span>(i,j)                   <span class="hljs-comment">// repmat(P,i,j)</span><br><br><br><span class="hljs-comment">// All the same as Matlab, but matlab doesn&#x27;t have *= style operators.</span><br><span class="hljs-comment">// Matrix-vector.  Matrix-matrix.   Matrix-scalar.</span><br>y  = M*x;          R  = P*Q;        R  = P*s;<br>a  = b*M;          R  = P - Q;      R  = s*P;<br>a *= M;            R  = P + Q;      R  = P/s;<br>                   R *= Q;          R  = s*P;<br>                   R += Q;          R *= s;<br>                   R -= Q;          R /= s;<br><br><span class="hljs-comment">// Vectorized operations on each element independently</span><br><span class="hljs-comment">// Eigen                       // Matlab</span><br>R = P.<span class="hljs-built_in">cwiseProduct</span>(Q);         <span class="hljs-comment">// R = P .* Q</span><br>R = P.<span class="hljs-built_in">array</span>() * s.<span class="hljs-built_in">array</span>();     <span class="hljs-comment">// R = P .* s</span><br>R = P.<span class="hljs-built_in">cwiseQuotient</span>(Q);        <span class="hljs-comment">// R = P ./ Q</span><br>R = P.<span class="hljs-built_in">array</span>() / Q.<span class="hljs-built_in">array</span>();     <span class="hljs-comment">// R = P ./ Q</span><br>R = P.<span class="hljs-built_in">array</span>() + s.<span class="hljs-built_in">array</span>();     <span class="hljs-comment">// R = P + s</span><br>R = P.<span class="hljs-built_in">array</span>() - s.<span class="hljs-built_in">array</span>();     <span class="hljs-comment">// R = P - s</span><br>R.<span class="hljs-built_in">array</span>() += s;                <span class="hljs-comment">// R = R + s</span><br>R.<span class="hljs-built_in">array</span>() -= s;                <span class="hljs-comment">// R = R - s</span><br>R.<span class="hljs-built_in">array</span>() &lt; Q.<span class="hljs-built_in">array</span>();         <span class="hljs-comment">// R &lt; Q</span><br>R.<span class="hljs-built_in">array</span>() &lt;= Q.<span class="hljs-built_in">array</span>();        <span class="hljs-comment">// R &lt;= Q</span><br>R.<span class="hljs-built_in">cwiseInverse</span>();              <span class="hljs-comment">// 1 ./ P</span><br>R.<span class="hljs-built_in">array</span>().<span class="hljs-built_in">inverse</span>();           <span class="hljs-comment">// 1 ./ P</span><br>R.<span class="hljs-built_in">array</span>().<span class="hljs-built_in">sin</span>()                <span class="hljs-comment">// sin(P)</span><br>R.<span class="hljs-built_in">array</span>().<span class="hljs-built_in">cos</span>()                <span class="hljs-comment">// cos(P)</span><br>R.<span class="hljs-built_in">array</span>().<span class="hljs-built_in">pow</span>(s)               <span class="hljs-comment">// P .^ s</span><br>R.<span class="hljs-built_in">array</span>().<span class="hljs-built_in">square</span>()             <span class="hljs-comment">// P .^ 2</span><br>R.<span class="hljs-built_in">array</span>().<span class="hljs-built_in">cube</span>()               <span class="hljs-comment">// P .^ 3</span><br>R.<span class="hljs-built_in">cwiseSqrt</span>()                  <span class="hljs-comment">// sqrt(P)</span><br>R.<span class="hljs-built_in">array</span>().<span class="hljs-built_in">sqrt</span>()               <span class="hljs-comment">// sqrt(P)</span><br>R.<span class="hljs-built_in">array</span>().<span class="hljs-built_in">exp</span>()                <span class="hljs-comment">// exp(P)</span><br>R.<span class="hljs-built_in">array</span>().<span class="hljs-built_in">log</span>()                <span class="hljs-comment">// log(P)</span><br>R.<span class="hljs-built_in">cwiseMax</span>(P)                  <span class="hljs-comment">// max(R, P)</span><br>R.<span class="hljs-built_in">array</span>().<span class="hljs-built_in">max</span>(P.<span class="hljs-built_in">array</span>())       <span class="hljs-comment">// max(R, P)</span><br>R.<span class="hljs-built_in">cwiseMin</span>(P)                  <span class="hljs-comment">// min(R, P)</span><br>R.<span class="hljs-built_in">array</span>().<span class="hljs-built_in">min</span>(P.<span class="hljs-built_in">array</span>())       <span class="hljs-comment">// min(R, P)</span><br>R.<span class="hljs-built_in">cwiseAbs</span>()                   <span class="hljs-comment">// abs(P)</span><br>R.<span class="hljs-built_in">array</span>().<span class="hljs-built_in">abs</span>()                <span class="hljs-comment">// abs(P)</span><br>R.<span class="hljs-built_in">cwiseAbs2</span>()                  <span class="hljs-comment">// abs(P.^2)</span><br>R.<span class="hljs-built_in">array</span>().<span class="hljs-built_in">abs2</span>()               <span class="hljs-comment">// abs(P.^2)</span><br>(R.<span class="hljs-built_in">array</span>() &lt; s).<span class="hljs-built_in">select</span>(P,Q );  <span class="hljs-comment">// (R &lt; s ? P : Q)</span><br>R = (Q.<span class="hljs-built_in">array</span>()==<span class="hljs-number">0</span>).<span class="hljs-built_in">select</span>(P,R) <span class="hljs-comment">// R(Q==0) = P(Q==0)</span><br>R = P.<span class="hljs-built_in">unaryExpr</span>(<span class="hljs-built_in">ptr_fun</span>(func)) <span class="hljs-comment">// R = arrayfun(func, P)   // with: scalar func(const scalar &amp;x);</span><br><br><br><span class="hljs-comment">// Reductions.</span><br><span class="hljs-type">int</span> r, c;<br><span class="hljs-comment">// Eigen                  // Matlab</span><br>R.<span class="hljs-built_in">minCoeff</span>()              <span class="hljs-comment">// min(R(:))</span><br>R.<span class="hljs-built_in">maxCoeff</span>()              <span class="hljs-comment">// max(R(:))</span><br>s = R.<span class="hljs-built_in">minCoeff</span>(&amp;r, &amp;c)    <span class="hljs-comment">// [s, i] = min(R(:)); [r, c] = ind2sub(size(R), i);</span><br>s = R.<span class="hljs-built_in">maxCoeff</span>(&amp;r, &amp;c)    <span class="hljs-comment">// [s, i] = max(R(:)); [r, c] = ind2sub(size(R), i);</span><br>R.<span class="hljs-built_in">sum</span>()                   <span class="hljs-comment">// sum(R(:))</span><br>R.<span class="hljs-built_in">colwise</span>().<span class="hljs-built_in">sum</span>()         <span class="hljs-comment">// sum(R)</span><br>R.<span class="hljs-built_in">rowwise</span>().<span class="hljs-built_in">sum</span>()         <span class="hljs-comment">// sum(R, 2) or sum(R&#x27;)&#x27;</span><br>R.<span class="hljs-built_in">prod</span>()                  <span class="hljs-comment">// prod(R(:))</span><br>R.<span class="hljs-built_in">colwise</span>().<span class="hljs-built_in">prod</span>()        <span class="hljs-comment">// prod(R)</span><br>R.<span class="hljs-built_in">rowwise</span>().<span class="hljs-built_in">prod</span>()        <span class="hljs-comment">// prod(R, 2) or prod(R&#x27;)&#x27;</span><br>R.<span class="hljs-built_in">trace</span>()                 <span class="hljs-comment">// trace(R)</span><br>R.<span class="hljs-built_in">all</span>()                   <span class="hljs-comment">// all(R(:))</span><br>R.<span class="hljs-built_in">colwise</span>().<span class="hljs-built_in">all</span>()         <span class="hljs-comment">// all(R)</span><br>R.<span class="hljs-built_in">rowwise</span>().<span class="hljs-built_in">all</span>()         <span class="hljs-comment">// all(R, 2)</span><br>R.<span class="hljs-built_in">any</span>()                   <span class="hljs-comment">// any(R(:))</span><br>R.<span class="hljs-built_in">colwise</span>().<span class="hljs-built_in">any</span>()         <span class="hljs-comment">// any(R)</span><br>R.<span class="hljs-built_in">rowwise</span>().<span class="hljs-built_in">any</span>()         <span class="hljs-comment">// any(R, 2)</span><br><br><span class="hljs-comment">// Dot products, norms, etc.</span><br><span class="hljs-comment">// Eigen                  // Matlab</span><br>x.<span class="hljs-built_in">norm</span>()                  <span class="hljs-comment">// norm(x).    Note that norm(R) doesn&#x27;t work in Eigen.</span><br>x.<span class="hljs-built_in">squaredNorm</span>()           <span class="hljs-comment">// dot(x, x)   Note the equivalence is not true for complex</span><br>x.<span class="hljs-built_in">dot</span>(y)                  <span class="hljs-comment">// dot(x, y)</span><br>x.<span class="hljs-built_in">cross</span>(y)                <span class="hljs-comment">// cross(x, y) Requires #include &lt;Eigen/Geometry&gt;</span><br><br><span class="hljs-comment">//// Type conversion</span><br><span class="hljs-comment">// Eigen                  // Matlab</span><br>A.<span class="hljs-built_in">cast</span>&lt;<span class="hljs-type">double</span>&gt;();         <span class="hljs-comment">// double(A)</span><br>A.<span class="hljs-built_in">cast</span>&lt;<span class="hljs-type">float</span>&gt;();          <span class="hljs-comment">// single(A)</span><br>A.<span class="hljs-built_in">cast</span>&lt;<span class="hljs-type">int</span>&gt;();            <span class="hljs-comment">// int32(A)</span><br>A.<span class="hljs-built_in">real</span>();                 <span class="hljs-comment">// real(A)</span><br>A.<span class="hljs-built_in">imag</span>();                 <span class="hljs-comment">// imag(A)</span><br><span class="hljs-comment">// if the original type equals destination type, no work is done</span><br><br><span class="hljs-comment">// Note that for most operations Eigen requires all operands to have the same type:</span><br>MatrixXf F = MatrixXf::<span class="hljs-built_in">Zero</span>(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>);<br>A += F;                <span class="hljs-comment">// illegal in Eigen. In Matlab A = A+F is allowed</span><br>A += F.<span class="hljs-built_in">cast</span>&lt;<span class="hljs-type">double</span>&gt;(); <span class="hljs-comment">// F converted to double and then added (generally, conversion happens on-the-fly)</span><br><br><span class="hljs-comment">// Eigen can map existing memory into Eigen matrices.</span><br><span class="hljs-type">float</span> array[<span class="hljs-number">3</span>];<br>Vector3f::<span class="hljs-built_in">Map</span>(array).<span class="hljs-built_in">fill</span>(<span class="hljs-number">10</span>);            <span class="hljs-comment">// create a temporary Map over array and sets entries to 10</span><br><span class="hljs-type">int</span> data[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-function">Matrix2i <span class="hljs-title">mat2x2</span><span class="hljs-params">(data)</span></span>;                    <span class="hljs-comment">// copies data into mat2x2</span><br>Matrix2i::<span class="hljs-built_in">Map</span>(data) = <span class="hljs-number">2</span>*mat2x2;           <span class="hljs-comment">// overwrite elements of data with 2*mat2x2</span><br>MatrixXi::<span class="hljs-built_in">Map</span>(data, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>) += mat2x2;      <span class="hljs-comment">// adds mat2x2 to elements of data (alternative syntax if size is not know at compile time)</span><br><br><span class="hljs-comment">// Solve Ax = b. Result stored in x. Matlab: x = A \ b.</span><br>x = A.<span class="hljs-built_in">ldlt</span>().<span class="hljs-built_in">solve</span>(b));  <span class="hljs-comment">// A sym. p.s.d.    #include &lt;Eigen/Cholesky&gt;</span><br>x = A.<span class="hljs-built_in">llt</span>() .<span class="hljs-built_in">solve</span>(b));  <span class="hljs-comment">// A sym. p.d.      #include &lt;Eigen/Cholesky&gt;</span><br>x = A.<span class="hljs-built_in">lu</span>()  .<span class="hljs-built_in">solve</span>(b));  <span class="hljs-comment">// Stable and fast. #include &lt;Eigen/LU&gt;</span><br>x = A.<span class="hljs-built_in">qr</span>()  .<span class="hljs-built_in">solve</span>(b));  <span class="hljs-comment">// No pivoting.     #include &lt;Eigen/QR&gt;</span><br>x = A.<span class="hljs-built_in">svd</span>() .<span class="hljs-built_in">solve</span>(b));  <span class="hljs-comment">// Stable, slowest. #include &lt;Eigen/SVD&gt;</span><br><span class="hljs-comment">// .ldlt() -&gt; .matrixL() and .matrixD()</span><br><span class="hljs-comment">// .llt()  -&gt; .matrixL()</span><br><span class="hljs-comment">// .lu()   -&gt; .matrixL() and .matrixU()</span><br><span class="hljs-comment">// .qr()   -&gt; .matrixQ() and .matrixR()</span><br><span class="hljs-comment">// .svd()  -&gt; .matrixU(), .singularValues(), and .matrixV()</span><br><br><span class="hljs-comment">// Eigenvalue problems</span><br><span class="hljs-comment">// Eigen                          // Matlab</span><br>A.<span class="hljs-built_in">eigenvalues</span>();                  <span class="hljs-comment">// eig(A);</span><br><span class="hljs-function">EigenSolver&lt;Matrix3d&gt; <span class="hljs-title">eig</span><span class="hljs-params">(A)</span></span>;     <span class="hljs-comment">// [vec val] = eig(A)</span><br>eig.<span class="hljs-built_in">eigenvalues</span>();                <span class="hljs-comment">// diag(val)</span><br>eig.<span class="hljs-built_in">eigenvectors</span>();               <span class="hljs-comment">// vec</span><br><span class="hljs-comment">// For self-adjoint matrices use SelfAdjointEigenSolver&lt;&gt;</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Program</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Eigen</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在Word中为公式自动编号</title>
    <link href="/2020/07/04/%E5%9C%A8Word%E4%B8%AD%E4%B8%BA%E5%85%AC%E5%BC%8F%E8%87%AA%E5%8A%A8%E7%BC%96%E5%8F%B7/"/>
    <url>/2020/07/04/%E5%9C%A8Word%E4%B8%AD%E4%B8%BA%E5%85%AC%E5%BC%8F%E8%87%AA%E5%8A%A8%E7%BC%96%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<ol><li><p>插入公式</p><p> 在Word 2013及以上版本中按下<code>Alt + =</code>后即可插入公式。</p></li><li><p>为公式自动编号</p><p>在公式后面输入<code>#(1)</code>后<code>Enter</code>即可为公式编号</p><p> $a^{2}+b^{2}&#x3D;c^{2}$ #(1) </p><p>如果公式较多，可以利用Word中<code>引用-&gt;插入题注</code>为公式自动更新编号：</p><ul><li><p>输入公式时，所有公式的编号都用一个特定符号来表示，如<code>NUM</code></p><p>$a^{2}+b^{2}&#x3D;c^{2}$ #(NUM) </p></li><li><p>在任意空白位置插入题注</p></li></ul><p> <img src="/2020/07/04/%E5%9C%A8Word%E4%B8%AD%E4%B8%BA%E5%85%AC%E5%BC%8F%E8%87%AA%E5%8A%A8%E7%BC%96%E5%8F%B7/2023-04-03-21-15-45.png"></p><ul><li>打开<code>替换</code>面板，将<code>NUM</code>替换成上面新建的题注，由于替换面板中无法包含题注格式，这时可以先将上面的题注复制到剪贴板上，然后将替换项表示为<code>^c</code>(这表示剪贴板内容)</li></ul><p> <img src="/2020/07/04/%E5%9C%A8Word%E4%B8%AD%E4%B8%BA%E5%85%AC%E5%BC%8F%E8%87%AA%E5%8A%A8%E7%BC%96%E5%8F%B7/2023-04-03-21-16-05.png"></p><ul><li><code>Ctrl+A</code>选中全文，右键<code>更新域</code>即可显示为正常的连续编号</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Office</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt开发Android程序（一）——— 环境配置</title>
    <link href="/2020/06/17/Qt%E5%BC%80%E5%8F%91Android%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E2%80%94-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/06/17/Qt%E5%BC%80%E5%8F%91Android%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E2%80%94-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>Qt Creator(QC)作为IDE，在安装QC时需要选择安装Android模块，此外，还需安装NDK，JDK，SDK开发套件。</p><ul><li><p>NDK</p><p>  下载<a href="https://developer.android.com/ndk/downloads/index.html">android-ndk-r21-windows-x86_64.zip</a>后安装</p></li><li><p>JDK</p><p>  下载<a href="http://jdk.android-studio.org/">jdk-8u5</a>后安装</p></li><li><p>SDK</p><p>  到<a href="http://sdk.android-studio.org/">此处</a>下载最新版SDK，SDK安装好后，打开SDK Manager，安装如下图所示项目：</p><p>  <img src="/2020/06/17/Qt%E5%BC%80%E5%8F%91Android%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E2%80%94-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2023-04-03-21-11-29.png"></p><p>  这里选择Android 7.1.1(API 25)套件</p><p>  <img src="/2020/06/17/Qt%E5%BC%80%E5%8F%91Android%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E2%80%94-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2023-04-03-21-11-59.png"></p><p>  <img src="/2020/06/17/Qt%E5%BC%80%E5%8F%91Android%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E2%80%94-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2023-04-03-21-12-16.png"></p></li><li><p>配置Qt Creator</p><p>打开菜单栏工具-选项-设备，将SDK，JDK，NDK路径填入</p><p><img src="/2020/06/17/Qt%E5%BC%80%E5%8F%91Android%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E2%80%94-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2023-04-03-21-12-47.png"></p></li><li><p>配置虚拟机(AVD)</p><p>打开AVD manager，点击右侧Creat创建一个虚拟机，参数配置如下（如果自己手机方便的话也可以直接用手机调试）：</p><p><img src="/2020/06/17/Qt%E5%BC%80%E5%8F%91Android%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E2%80%94-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2023-04-03-21-13-08.png"></p><p>点击Start查看运行效果</p><p><img src="/2020/06/17/Qt%E5%BC%80%E5%8F%91Android%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E2%80%94-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2023-04-03-21-13-31.png"></p></li></ul><h2 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h2><ol><li><p>打开Qt Creator，新建一个QWidget项目，创建一个按钮</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mainwindow.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QVBoxLayout&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QHBoxLayout&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QPushButton&gt;</span></span><br><br>MainWindow::<span class="hljs-built_in">MainWindow</span>(QWidget *parent)<br>    : <span class="hljs-built_in">QWidget</span>(parent)<br>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setupUI</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainWindow::setupUI</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> vbox = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QVBoxLayout</span>();<br>    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setLayout</span>(vbox);<br><br>    <span class="hljs-keyword">auto</span> btn =<span class="hljs-keyword">new</span> <span class="hljs-built_in">QPushButton</span>(<span class="hljs-string">&quot;Click here&quot;</span>);<br>    <span class="hljs-keyword">auto</span> hbox = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QHBoxLayout</span>();<br>    hbox-&gt;<span class="hljs-built_in">addStretch</span>(<span class="hljs-number">1</span>);<br>    hbox-&gt;<span class="hljs-built_in">addWidget</span>(btn);<br>    hbox-&gt;<span class="hljs-built_in">addStretch</span>(<span class="hljs-number">1</span>);<br><br>    vbox-&gt;<span class="hljs-built_in">addLayout</span>(hbox);<br><br>    <span class="hljs-built_in">connect</span>(btn, &amp;QPushButton::clicked, [=]()&#123;<br>        btn-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;Changed&quot;</span>);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>点击QC左侧项目，配置Android项目</p><p>在Build步骤里，ABIs选择<strong>x86_64</strong>，Android build SDK选择<strong>android-25</strong></p><p><img src="/2020/06/17/Qt%E5%BC%80%E5%8F%91Android%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E2%80%94-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2023-04-03-21-14-04.png"></p><p><img src="/2020/06/17/Qt%E5%BC%80%E5%8F%91Android%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E2%80%94-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2023-04-03-21-14-25.png"></p></li><li><p>调试</p><p>点击左下角锤子符号编译，点击绿色三角运行，选择前面配置的虚拟机作为调试机，查看运行效果</p><p><img src="/2020/06/17/Qt%E5%BC%80%E5%8F%91Android%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E2%80%94-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2023-04-03-21-14-44.png"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Program</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Matlab绘制局部放大图</title>
    <link href="/2020/05/27/Matlab%E7%BB%98%E5%88%B6%E5%B1%80%E9%83%A8%E6%94%BE%E5%A4%A7%E5%9B%BE/"/>
    <url>/2020/05/27/Matlab%E7%BB%98%E5%88%B6%E5%B1%80%E9%83%A8%E6%94%BE%E5%A4%A7%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>可以采用<code>axes</code>函数在当前图中插入一个小图的方法绘制局部放大图。<br>如下代码：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs matlab">func = &#123;@(x) <span class="hljs-built_in">sin</span>(x), @(x) <span class="hljs-built_in">cos</span>(x)&#125;;<br>x = <span class="hljs-built_in">linspace</span>(<span class="hljs-number">0</span>, <span class="hljs-number">15</span>);<br><br><span class="hljs-built_in">figure</span>;<br>ax1 = axes(<span class="hljs-string">&#x27;Position&#x27;</span>, [<span class="hljs-number">0.11</span>, <span class="hljs-number">0.15</span>, <span class="hljs-number">0.8</span>, <span class="hljs-number">0.8</span>]); <span class="hljs-comment">% 主图</span><br>ax2 = axes(<span class="hljs-string">&#x27;Position&#x27;</span>, [<span class="hljs-number">0.5</span>, <span class="hljs-number">0.65</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.25</span>]); <span class="hljs-comment">% 局部图</span><br><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(func)<br>    <span class="hljs-built_in">plot</span>(ax1, x, func&#123;<span class="hljs-built_in">i</span>&#125;(x));<br>    <span class="hljs-built_in">hold</span>(ax1, <span class="hljs-string">&#x27;on&#x27;</span>);<br><br>    <span class="hljs-built_in">plot</span>(ax2, x, func&#123;<span class="hljs-built_in">i</span>&#125;(x));<br>    <span class="hljs-built_in">hold</span>(ax2, <span class="hljs-string">&#x27;on&#x27;</span>);<br><span class="hljs-keyword">end</span><br><br>xlim(ax1, [<span class="hljs-number">0</span>, <span class="hljs-number">15</span>])<br>ylim(ax1, [<span class="hljs-number">-1</span>, <span class="hljs-number">3</span>])<br>xlabel(ax1, <span class="hljs-string">&#x27;$x$&#x27;</span>, <span class="hljs-string">&#x27;Interpreter&#x27;</span>, <span class="hljs-string">&#x27;latex&#x27;</span>);<br>ylabel(ax1, <span class="hljs-string">&#x27;$y$&#x27;</span>, <span class="hljs-string">&#x27;Interpreter&#x27;</span>, <span class="hljs-string">&#x27;latex&#x27;</span>);<br><span class="hljs-built_in">legend</span>(ax1, &#123;<span class="hljs-string">&#x27;$sin$&#x27;</span>, <span class="hljs-string">&#x27;$cos$&#x27;</span>&#125;, <span class="hljs-string">&#x27;Location&#x27;</span>, <span class="hljs-string">&#x27;northwest&#x27;</span>, <span class="hljs-string">&#x27;Interpreter&#x27;</span>, <span class="hljs-string">&#x27;latex&#x27;</span>)<br><br>xlim(ax2, [<span class="hljs-number">2</span>, <span class="hljs-number">6</span>])<br>ylim(ax2, [<span class="hljs-number">-1</span>, <span class="hljs-number">-0.3</span>])<br></code></pre></td></tr></table></figure><p>输出：</p><div align="center"><img src="/2020/05/27/Matlab%E7%BB%98%E5%88%B6%E5%B1%80%E9%83%A8%E6%94%BE%E5%A4%A7%E5%9B%BE/2023-04-03-21-10-16.png" width="50%" height="50%"></div>]]></content>
    
    
    <categories>
      
      <category>Program</category>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++矩阵库（2）</title>
    <link href="/2020/05/22/C-%E7%9F%A9%E9%98%B5%E5%BA%93%EF%BC%882%EF%BC%89/"/>
    <url>/2020/05/22/C-%E7%9F%A9%E9%98%B5%E5%BA%93%EF%BC%882%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前介绍了一些<a href="https://ting2938.github.io/2020/05/20/C-%E7%9F%A9%E9%98%B5%E5%BA%93/">常见的C++矩阵库</a>，这些矩阵库用起来都很方便，但是在本人的科研过程中并不会用到这些矩阵库的高级功能（如LU分解、求逆矩阵等），只是需要其作为容器存放数据，而且需要一些定制功能（比如元素查找、求积分微分等），因此我写了一个简单的、只包含头文件的矩阵库。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>由于是只包含头文件的，所以很容易包含到其他项目中，安装方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/TING2938/Analysis.git<br><span class="hljs-built_in">cp</span> -r Analysis/gmxProject/Analysis/Core/include path/to/your/project<br></code></pre></td></tr></table></figure><p>然后设置项目中包含<code>include</code>文件夹就可以用了。</p><h2 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h2><p>一个简单的Demo如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;itp/core&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">mati <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i != A.<span class="hljs-built_in">nrow</span>(); ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j != A.<span class="hljs-built_in">ncol</span>(); ++j)<br>        &#123;<br>            <span class="hljs-built_in">A</span>(i, j) = <span class="hljs-number">3</span>*i+<span class="hljs-number">5</span>*j;<br>            <span class="hljs-comment">// 也可以用方括号进行索引</span><br>            <span class="hljs-comment">// A[i][j] = 3*i+5*j;</span><br>        &#125;<br>    &#125;<br><br>    A.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;A:&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>会得到如下输出:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">A</span>:<br>           <span class="hljs-attribute">0</span>           <span class="hljs-number">5</span>          <span class="hljs-number">10</span>          <span class="hljs-number">15</span><br>           <span class="hljs-attribute">3</span>           <span class="hljs-number">8</span>          <span class="hljs-number">13</span>          <span class="hljs-number">18</span><br>           <span class="hljs-attribute">6</span>          <span class="hljs-number">11</span>          <span class="hljs-number">16</span>          <span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><p>其中，<code>mati</code>类型等为一些常用的类型，<code>using mati = itp::Matrix&lt;int&gt;</code>，其他类型如<code>matd</code>、<code>matu</code>、<code>matb</code>分别对应模板参数为<code>double</code>、<code>size_t</code>、<code>bool</code>的版本。</p><h2 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Matrix</span>();<br><span class="hljs-built_in">Matrix</span>(<span class="hljs-type">size_t</span> nrow, <span class="hljs-type">size_t</span> ncol); <span class="hljs-comment">// 指定行列大小，初始值未定义</span><br><span class="hljs-built_in">Matrix</span>(<span class="hljs-type">size_t</span> nrow, <span class="hljs-type">size_t</span> ncol, T init); <span class="hljs-comment">// 指定初始值为 init</span><br><span class="hljs-built_in">Matrix</span>(<span class="hljs-type">size_t</span> nrow, <span class="hljs-type">size_t</span> ncol, conststd::initializer_list&lt;T&gt;&amp; it); <span class="hljs-comment">//指定行列大小，并由初始化列表初始化，如 mati A(2, 3, &#123;2, 3, 4, 5, 5, 6&#125;);</span><br><span class="hljs-built_in">Matrix</span>(<span class="hljs-type">const</span> std::initializer_list&lt;conststd::initializer_list&lt;T&gt;&gt;&amp; it); <span class="hljs-comment">// 由初始化列表初始化，如 mati B = &#123;&#123;5, 6, 8&#125;, &#123;7, 10, 13&#125;&#125;; 初始化为2行3列的矩阵</span><br><span class="hljs-built_in">Matrix</span>(T* p, <span class="hljs-type">size_t</span> nrow, <span class="hljs-type">size_t</span> ncol, <span class="hljs-type">bool</span> copy= <span class="hljs-literal">true</span>); <span class="hljs-comment">// 由指针初始化，默认拷贝指针指向的资源，copy=false时不拷贝资源，此时p的生命周期一定要大于矩阵的生命周期</span><br><span class="hljs-built_in">Matrix</span>(Matrix&lt;T&gt;&amp;&amp; mat) <span class="hljs-keyword">noexcept</span>; <span class="hljs-comment">// 移动构造</span><br><span class="hljs-built_in">Matrix</span>(<span class="hljs-type">const</span> Matrix&lt;T&gt;&amp; mat); <span class="hljs-comment">// 拷贝构造</span><br>~<span class="hljs-built_in">Matrix</span>(); <span class="hljs-comment">// 析构函数</span><br>Matrix&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(Matrix&lt;T&gt;&amp;&amp; mat) <span class="hljs-keyword">noexcept</span>; <span class="hljs-comment">// 移动赋值运算符</span><br>Matrix&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Matrix&lt;T&gt;&amp; mat); <span class="hljs-comment">// 拷贝赋值运算符</span><br></code></pre></td></tr></table></figure><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">T* <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> i) <span class="hljs-keyword">noexcept</span>;<br><span class="hljs-type">const</span> T* <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> i) <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span>;<br>Vector&lt;T&gt; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> Matrix&lt;<span class="hljs-type">bool</span>&gt;&amp; bol) <span class="hljs-type">const</span>;<br><span class="hljs-function">T&amp; <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">size_t</span> i, <span class="hljs-type">size_t</span> j)</span> <span class="hljs-keyword">noexcept</span></span>;<br><span class="hljs-function"><span class="hljs-type">const</span> T&amp; <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">size_t</span> i, <span class="hljs-type">size_t</span> j)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br><span class="hljs-comment">// row major</span><br><span class="hljs-function">T&amp; <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">size_t</span> i)</span> <span class="hljs-keyword">noexcept</span></span>;<br><span class="hljs-function"><span class="hljs-type">const</span> T&amp; <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">size_t</span> i)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br><span class="hljs-function">Vector&lt;T&gt; <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Matrix&lt;<span class="hljs-type">bool</span>&gt;&amp; bol)</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><p>采用row major内存布局，索引若只含一维，则将矩阵视为一维向量进行索引，如<code>A[4] = 3</code>;<br>注意，可以采用<code>()</code>和<code>[]</code>两种方法进行索引，如<code>A(1, 2) = 5; B[4][3] = 6</code>，两种方法效果一样</p><h3 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h3><p><strong>注意：矩阵所有运算都是将矩阵视为向量后的运算，并不涉及真正的矩阵运算。</strong></p><p>例如，<code>mati A(3, 4), B(3, 4)</code></p><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td><code>A + 3</code></td><td><code>A</code>所有元素加3</td></tr><tr><td><code>A + B</code></td><td><code>A</code>与<code>B</code>对应元素相加</td></tr><tr><td><code>A &gt; 2</code></td><td><code>A</code>中元素分别与2比较，返回与<code>A</code>形状相同的bool型矩阵</td></tr><tr><td><code>A &gt; B</code></td><td><code>A</code>中元素分别与<code>B</code>中元素比较，返回与<code>A</code>(或<code>B</code>)形状相同的bool型矩阵</td></tr><tr><td><code>!A</code></td><td>对<code>A</code>中元素分别求非运算，返回与<code>A</code>形状相同的bool型矩阵</td></tr><tr><td><code>A &amp;&amp; B</code></td><td>对<code>A</code>与<code>B</code>中对应元素求与运算，返回与<code>A</code>(或<code>B</code>)形状相同的bool型矩阵</td></tr><tr><td><code>A</code> &amp;#124;&amp;#124; <code>B</code></td><td>对<code>A</code>与<code>B</code>中对应元素求或运算，返回与<code>A</code>(或<code>B</code>)形状相同的bool型矩阵</td></tr></tbody></table><p>矩阵与数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">Matrix&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> T&amp; val);<br>Matrix&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>-=(<span class="hljs-type">const</span> T&amp; val);<br>Matrix&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>*=(<span class="hljs-type">const</span> T&amp; val);<br>Matrix&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>/=(<span class="hljs-type">const</span> T&amp; val);<br><br>Matrix&lt;T&gt; <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> T&amp; val) <span class="hljs-type">const</span>;<br>Matrix&lt;T&gt; <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> T&amp; val) <span class="hljs-type">const</span>;<br>Matrix&lt;T&gt; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> T&amp; val) <span class="hljs-type">const</span>;<br>Matrix&lt;T&gt; <span class="hljs-keyword">operator</span>/(<span class="hljs-type">const</span> T&amp; val) <span class="hljs-type">const</span>;<br></code></pre></td></tr></table></figure><p>矩阵与矩阵：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">Matrix&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> Matrix&lt;T&gt;&amp; mat);<br>Matrix&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>-=(<span class="hljs-type">const</span> Matrix&lt;T&gt;&amp; mat);<br>Matrix&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>*=(<span class="hljs-type">const</span> Matrix&lt;T&gt;&amp; mat);<br>Matrix&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>/=(<span class="hljs-type">const</span> Matrix&lt;T&gt;&amp; mat);<br><br>Matrix&lt;T&gt; <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Matrix&lt;T&gt;&amp; mat) <span class="hljs-type">const</span>;<br>Matrix&lt;T&gt; <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Matrix&lt;T&gt;&amp; mat) <span class="hljs-type">const</span>;<br>Matrix&lt;T&gt; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Matrix&lt;T&gt;&amp; mat) <span class="hljs-type">const</span>;<br>Matrix&lt;T&gt; <span class="hljs-keyword">operator</span>/(<span class="hljs-type">const</span> Matrix&lt;T&gt;&amp; mat) <span class="hljs-type">const</span>;<br></code></pre></td></tr></table></figure><p>矩阵与数之间的比较：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">Matrix&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> T&amp; value) <span class="hljs-type">const</span>;<br>Matrix&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> T&amp; value) <span class="hljs-type">const</span>;<br>Matrix&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> T&amp; value) <span class="hljs-type">const</span>;<br>Matrix&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> T&amp; value) <span class="hljs-type">const</span>;<br>Matrix&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> T&amp; value) <span class="hljs-type">const</span>;<br>Matrix&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-type">const</span> T&amp; value) <span class="hljs-type">const</span>;<br></code></pre></td></tr></table></figure><p>矩阵与矩阵之间的比较：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">Matrix&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Matrix&lt;T&gt;&amp; mat) <span class="hljs-type">const</span>;<br>Matrix&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> Matrix&lt;T&gt;&amp; mat) <span class="hljs-type">const</span>;<br>Matrix&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> Matrix&lt;T&gt;&amp; mat) <span class="hljs-type">const</span>;<br>Matrix&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Matrix&lt;T&gt;&amp; mat) <span class="hljs-type">const</span>;<br>Matrix&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> Matrix&lt;T&gt;&amp; mat) <span class="hljs-type">const</span>;<br>Matrix&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-type">const</span> Matrix&lt;T&gt;&amp; mat) <span class="hljs-type">const</span>;<br></code></pre></td></tr></table></figure><p>逻辑运算符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">Matrix&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-keyword">operator</span>!() <span class="hljs-type">const</span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> S&gt;<br>Matrix&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-keyword">operator</span>&amp;&amp;(<span class="hljs-type">const</span> Matrix&lt;S&gt;&amp; mat) <span class="hljs-type">const</span>;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> S&gt;<br>Matrix&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-keyword">operator</span>||(<span class="hljs-type">const</span> Matrix&lt;S&gt;&amp; mat) <span class="hljs-type">const</span>;<br></code></pre></td></tr></table></figure><h3 id="矩阵切片操作"><a href="#矩阵切片操作" class="headerlink" title="矩阵切片操作"></a>矩阵切片操作</h3><p>例如，<code>mati A(3, 4)</code></p><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td><code>A.part(2, &#123;1, 3&#125;)</code></td><td>第2行、第1到3列</td></tr><tr><td><code>A.part(&#123;0, 2&#125;, 1)</code></td><td>第0到2行、第1列</td></tr><tr><td><code>A.part(&#123;0, 2&#125;, &#123;1, 3&#125;)</code></td><td>第0到2行、第1到3列</td></tr><tr><td><code>A.head(2)</code></td><td>前2行</td></tr><tr><td><code>A.tail(2)</code></td><td>后2行</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Matrix&lt;T&gt; <span class="hljs-title">part</span><span class="hljs-params">(<span class="hljs-type">const</span> Rg&amp; row, <span class="hljs-type">const</span> Rg&amp; col)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">Vector&lt;T&gt; <span class="hljs-title">part</span><span class="hljs-params">(<span class="hljs-type">size_t</span> row, <span class="hljs-type">const</span> Rg&amp; rg, boolcopy = <span class="hljs-literal">false</span>)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">Vector&lt;T&gt; <span class="hljs-title">part</span><span class="hljs-params">(<span class="hljs-type">const</span> Rg&amp; rg, <span class="hljs-type">size_t</span> col)</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-function">Matrix&lt;T&gt; <span class="hljs-title">head</span><span class="hljs-params">(<span class="hljs-type">size_t</span> row = <span class="hljs-number">10</span>)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">Matrix&lt;T&gt; <span class="hljs-title">tail</span><span class="hljs-params">(<span class="hljs-type">size_t</span> row = <span class="hljs-number">10</span>)</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><p>例如，<code>mati A(3, 4), B(4, 5);</code></p><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td><code>A.nrow()</code></td><td>行数</td></tr><tr><td><code>A.ncol()</code></td><td>列数</td></tr><tr><td><code>A.size()</code></td><td>存入<code>std::array</code>的行列数</td></tr><tr><td><code>A.size(0)</code></td><td>行数</td></tr><tr><td><code>A.size(1)</code></td><td>列数</td></tr><tr><td><code>A.capacity()</code></td><td>内部指针的容量</td></tr><tr><td><code>A.fill(3)</code></td><td>用3填充整个矩阵</td></tr><tr><td><code>A.resize(4, 5)</code></td><td>重置大小为4行5列</td></tr><tr><td><code>A.clear()</code></td><td>使矩阵的行列数都为0</td></tr><tr><td><code>A.fillRandom(std::uniform_int_distribution&lt;int&gt;(1, 6))</code></td><td>用从1到6之间的均匀分布随机数填充，随机数用法参考标准库中<a href="https://en.cppreference.com/w/cpp/header/random">随机数部分</a></td></tr><tr><td><code>A.dot(B)</code></td><td><code>A</code>与<code>B</code>的矩阵点乘</td></tr><tr><td><code>A.transpose()</code></td><td>转置</td></tr><tr><td><code>A.max(COL)</code></td><td>列方向上的最大值，返回向量</td></tr><tr><td><code>A.min(COL)</code></td><td>列方向上的最小值，返回向量</td></tr><tr><td><code>A.sum(COL)</code></td><td>列方向上的和，返回向量</td></tr><tr><td><code>A.mean(COL)</code></td><td>列方向上的平均值，返回向量</td></tr><tr><td><code>A.stdev(COL)</code></td><td>列方向上的标准差，返回向量</td></tr><tr><td><code>A.max(2, COL)</code></td><td>第2列上的最大值</td></tr><tr><td><code>A.print(&quot;A:&quot;, std::cout, &quot;&#123;:12&#125;&quot;)</code></td><td>向<code>std::cout</code>中打印输出<code>A</code>，提示符为<code>A:</code>，格式为<code>&quot;&#123;:12&#125;&quot;</code></td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">nrow</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ncol</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">std::array&lt;<span class="hljs-type">size_t</span>, 2&gt; <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">size_t</span> i)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">/* i &lt; 2. */</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">size_t</span>&amp; <span class="hljs-title">capacity</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">size_t</span>&amp; <span class="hljs-title">capacity</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">Matrix&lt;T&gt;&amp; <span class="hljs-title">fill</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value)</span></span>;<br><span class="hljs-function">Matrix&lt;T&gt;&amp; <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-type">size_t</span> nrow, <span class="hljs-type">size_t</span> ncol)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/* https://en.cppreference.com/w/cpp/header/random */</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Distribution&gt;<br><span class="hljs-function">Matrix&lt;T&gt;&amp; <span class="hljs-title">fillRandom</span><span class="hljs-params">(Distribution&amp;&amp; dist)</span></span>;<br><br><span class="hljs-function">Matrix&lt;T&gt; <span class="hljs-title">dot</span><span class="hljs-params">(<span class="hljs-type">const</span> Matrix&lt;T&gt;&amp; mat)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">Matrix&lt;T&gt; <span class="hljs-title">transpose</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-comment">/* calculate value of block  */</span><br><span class="hljs-function">Vector&lt;T&gt; <span class="hljs-title">max</span><span class="hljs-params">(Axis axis = COL)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">Vector&lt;T&gt; <span class="hljs-title">min</span><span class="hljs-params">(Axis axis = COL)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">Vector&lt;T&gt; <span class="hljs-title">sum</span><span class="hljs-params">(Axis axis = COL)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">Vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">mean</span><span class="hljs-params">(Axis axis = COL)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">Vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">stdev</span><span class="hljs-params">(Axis axis = COL, <span class="hljs-type">bool</span> sample = <span class="hljs-literal">true</span>)</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-comment">/* calculate value of row or column */</span><br><span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n, Axis axis = COL)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">T <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n, Axis axis = COL)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">T <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n, Axis axis = COL)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">mean</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n, Axis axis = COL)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">stdev</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n, Axis axis = COL, <span class="hljs-type">bool</span> sample = <span class="hljs-literal">true</span>)</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(std::string str = <span class="hljs-string">&quot;&quot;</span>, std::ostream&amp; os = std::cout, std::string fmt=<span class="hljs-string">&quot;&#123;:12&#125;&quot;</span>)</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Program</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++矩阵库</title>
    <link href="/2020/05/20/C-%E7%9F%A9%E9%98%B5%E5%BA%93/"/>
    <url>/2020/05/20/C-%E7%9F%A9%E9%98%B5%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>C++以其及其优异的计算速度在科学计算、工业工程等领域得到广泛的应用，在数值计算方面，调用矩阵库能简化编程过程，提高计算速度，下面介绍几种常用的矩阵库及其用法，此外，我也写了一个矩阵库在自己科研分析中<a href="https://ting2938.github.io/2020/05/22/C-%E7%9F%A9%E9%98%B5%E5%BA%93%EF%BC%882%EF%BC%89/">C++矩阵库（2）</a>。</p><h3 id="Eigen"><a href="#Eigen" class="headerlink" title="Eigen"></a>Eigen</h3><p><a href="http://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen</a>是采用C++模板技术编写的纯头文件库，用法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Eigen/Dense&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Eigen::MatrixXd <span class="hljs-title">mat</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">3</span>; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j != <span class="hljs-number">4</span>; ++j)<br>        &#123;<br>            <span class="hljs-built_in">mat</span>(i, j) = <span class="hljs-number">3</span>*i+<span class="hljs-number">5</span>*j;<br>        &#125;<br>    &#125;<br>    std::cout &lt;&lt; mat &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Armadillo"><a href="#Armadillo" class="headerlink" title="Armadillo"></a>Armadillo</h3><p><a href="http://arma.sourceforge.net/">Armadillo</a>的语法与Matlab语法很相识，从Matlab迁移到Armadillo很方便，用法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Armadillo&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">arma::mat <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">3</span>; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j != <span class="hljs-number">4</span>; ++j)<br>        &#123;<br>            <span class="hljs-built_in">A</span>(i, j) = <span class="hljs-number">3</span>*i+<span class="hljs-number">5</span>*j;<br>        &#125;<br>    &#125;<br>    A.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;A:&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Boost"><a href="#Boost" class="headerlink" title="Boost"></a>Boost</h3><p><a href="https://www.boost.org/">Boost</a>在C++中地位非常高，被称为C++的准标准库，其中的ublas模块包含矩阵类，用法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/numeric/ublas/matrix.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/numeric/ublas/io.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">namespace</span> ublas = boost::numeric::ublas;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">ublas::matrix&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size1</span>(); ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> j = <span class="hljs-number">0</span>; j &lt; A.<span class="hljs-built_in">size2</span>(); ++j)<br>            <span class="hljs-built_in">A</span>(i, j) = <span class="hljs-number">3</span>*i + j;<br>std::cout &lt;&lt; A &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Program</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++控制台设置滚动输出</title>
    <link href="/2020/05/19/C-%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%AE%BE%E7%BD%AE%E6%BB%9A%E5%8A%A8%E8%BE%93%E5%87%BA/"/>
    <url>/2020/05/19/C-%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%AE%BE%E7%BD%AE%E6%BB%9A%E5%8A%A8%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在写C++控制台程序时，我们可能会给程序添加进度条，也就是要程序在同一行反复输出，可以用特殊字符实现。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="在Windows下"><a href="#在Windows下" class="headerlink" title="在Windows下"></a>在Windows下</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">10</span>; ++i)<br>&#123;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// do something</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r&quot;</span>);<br>    <span class="hljs-built_in">fflush</span>(stdout);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %d&quot;</span>, i);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在Linux下"><a href="#在Linux下" class="headerlink" title="在Linux下"></a>在Linux下</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">10</span>; ++i)<br>&#123;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// do something</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\033[k&quot;</span>);<br>    <span class="hljs-built_in">fflush</span>(stdout);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %d&quot;</span>, i);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这里写一个函数<code>setScrollOutput()</code>来实现这一过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">setScrollOutput</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _WIN32</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\033[k&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// _WIN32</span></span><br><span class="hljs-built_in">fflush</span>(stdout);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">10</span>; ++i)<br>&#123;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// do something</span><br><br>    <span class="hljs-built_in">setScrollOutput</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %d&quot;</span>, i);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Program</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VMD原子选区语法</title>
    <link href="/2020/05/19/VMD%E5%8E%9F%E5%AD%90%E9%80%89%E5%8C%BA%E8%AF%AD%E6%B3%95/"/>
    <url>/2020/05/19/VMD%E5%8E%9F%E5%AD%90%E9%80%89%E5%8C%BA%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a><strong>1 前言</strong></h2><p>VMD（<a href="http://www.ks.uiuc.edu/Research/vmd/">http://www.ks.uiuc.edu/Research/vmd/</a>）是极其强大、灵活的化学体系可视化程序，笔者之前也写过不少相关文章，见<a href="http://sobereva.com/category/VMD/">http://sobereva.com/category/VMD/</a>。VMD的选择语句(selection)用来选择满足特定要求的体系中的原子，其用法极度简单灵活，对于VMD的使用至关重要。</p><p>选择语句在VMD里用的地方非常多，无处不在。比如如果想在图形窗口只显示指定的区域，那么可以在Graphics - Representation里在selected atoms的地方写上选择语句。如果想把指定的区域保存成新文件，那么可以在File - Save coordinates里在Selected atoms写上选择语句。很多自带的插件也需要选择语句，比如VMD自带的径向分布函数计算插件，里面selection 1、selection 2就是让你输入选择语句的地方。在VMD里还可以用atomselect命令创建对象，显然也要输入选择语句。顺带一提，如今GROMACS里也可以用selections语句，和VMD很大程度一致，但不完全一致。</p><p>鉴于经常有人问选择语句怎么用，每次回复很麻烦，笔者遂专门写个小文说一下。这些内容在“北京科音分子动力学与GROMACS培训班里”（<a href="http://www.keinsci.com/workshop/KGMX_content.html">http://www.keinsci.com/workshop/KGMX_content.html</a>）里大多也都讲过，之前的学员可以复习一下。本文内容对应VMD 1.9.3。下文从简单到复杂进行讲解。</p><h2 id="2-单关键词（Singleword）"><a href="#2-单关键词（Singleword）" class="headerlink" title="2 单关键词（Singleword）"></a><strong>2 单关键词（Singleword）</strong></h2><p>有一些关键词可以直接选择特定原子，以下举例一部分：</p><p> all：所有原子</p><p> none：不选择任何原子</p><p> noh：氢以外的原子（即重原子）</p><p> ion：离子</p><p> water：水</p><p> backbone：生物大分子骨架</p><p> sidechain：生物大分子侧链</p><p> protein：蛋白</p><p> nucleic：核酸</p><p> helix：螺旋</p><p> alpha_helix：alpha螺旋（是helix中的子集，较长一段螺旋才算）</p><p> sheet：折叠</p><p> turn：转角</p><p> coil：盘绕</p><p> alpha：蛋白质的alpha碳</p><p> acidic：PH&#x3D;7时带负电氨基酸</p><p> basic：PH&#x3D;7时带正电氨基酸</p><p> charged：acidic和basic的并集</p><p> neutral：电中性氨基酸</p><p> polar：极性残基</p><p> hydrophobic：疏水性残基</p><p> bonded：成键的原子</p><p> hetero：非蛋白质和核酸的部分</p><p> carbon、hydrogen、oxygen、nitrogen、sulfur：相应元素。对于其它元素没法这么输入元素名来选择</p><p>这些单关键词实际上可以在Representation界面里的Selections标签页里的Singlewords直接看到，可见可以用的单关键词远不止上述这些。有些单关键词其实是复合选择语句，比如你选中hetero，就会看到其定义其实是not (protein or nucleic)。</p><p><img src="/2020/05/19/VMD%E5%8E%9F%E5%AD%90%E9%80%89%E5%8C%BA%E8%AF%AD%E6%B3%95/2023-04-03-21-19-43.png"></p><p>注意有些情况下，单关键词未必能如实选择相应的区域。比如你载入的结构里有水，如果输入文件里水的残基名很特殊，比如叫FFF，那么VMD就不会把这个残基识别成水分子，用water关键词的时候也没法选中这些水。</p><h2 id="3-一般关键词"><a href="#3-一般关键词" class="headerlink" title="3 一般关键词"></a><strong>3 一般关键词</strong></h2><p>用下面这些关键词可以通过属性选取原子，都是后面要接参数的</p><p> name：原子名。例：name OW选择原子名叫OW的原子</p><p> index：原子序号（从0开始！）。例：index 4</p><p> serial：原子序号（从1开始）</p><p> type：原子类型。例：type CA选择CA原则类型</p><p> element：元素名。例：element P选择磷原子</p><p> resname：残基名。例：resname ALA代表选择丙氨酸</p><p> residue：残基编号，从0开始。例resid 372代表选择372号残基</p><p> resid：残基编号，从1开始。若结构文件里有残基号则与之一致</p><p> chain：链名。例：chain B代表选择B链</p><p> fragment：片段编号。VMD对每个键连的片段自动设定一个编号。例：fragment 4代表选择片段4</p><p> numbonds：成键数目。例：numbonds&#x3D;2或numbonds 2代表选形成了两个键的原子</p><p> structure：二级结构。例：structure H代表选择螺旋(helix)区域</p><p> x,y,z：X&#x2F;Y&#x2F;Z笛卡尔坐标</p><p> vx,vy,vz：X&#x2F;Y&#x2F;Z方向速度</p><p> beta：pdb文件中的beta值</p><p> occupancy：pdb文件中的原子占有率</p><p> mass：原子质量</p><p> charge：原子电荷</p><p> phi、psi：蛋白质骨架角度</p><p> radius：原子半径</p><p>…等等</p><p>每个属性后面能接什么值，在Selections标签页里都能看到，不确定的话看一眼便知：</p><p><img src="/2020/05/19/VMD%E5%8E%9F%E5%AD%90%E9%80%89%E5%8C%BA%E8%AF%AD%E6%B3%95/2023-04-03-21-19-24.png"></p><p>许多属性并非对于任何输入文件都能用。比如：</p><p>·使用charge属性，必须输入的文件里体现了原子电荷才行，比如可以用mol2或pqr，后者详见《使用Multiwfn+VMD以原子着色方式表现原子电荷、自旋布居、电荷转移、简缩福井函数》（<a href="http://sobereva.com/425">http://sobereva.com/425</a>）。</p><p>·使用beta属性，通常需要用pdb文件作为输入，因为里面专门有一列记录B因子信息。</p><p>·用type的话必须载入拓扑文件才行。</p><p>·用vx、vy、vz的话，对于GROMACS用户，参看《使VMD读入Gromacs产生的trr轨迹中速度信息的方法》（<a href="http://sobereva.com/117">http://sobereva.com/117</a>）。</p><p>·element信息是很多文件里没有的，比如GROMACS的.gro文件里就没体现</p><h2 id="4-选择语句中可利用的规则"><a href="#4-选择语句中可利用的规则" class="headerlink" title="4 选择语句中可利用的规则"></a><strong>4 选择语句中可利用的规则</strong></h2><p>在选择语句中有以下规则可以利用，通过组合、嵌套，使得选择语句无比强大</p><p>·可以写多个参数一次选择一批，彼此间用空格分隔</p><p>·可以用… to …选择特定范围</p><p>·可以用与、或、非这些逻辑关系：and、or、not</p><p>·可以用( )或{ }指定语句处理的优先顺序</p><p>·双引号内的字符会被视为整体，并且可以使用正则表达式</p><p>·用单引号扩住则里面的字符可以避免被转义</p><p>·可以用判断语句：&lt;, &lt;&#x3D;, &#x3D;, &gt;&#x3D;, &gt;, !&#x3D;</p><p>·可以用函数：sqr（平方）, sqrt（开根号）, abs（绝对值）, sin, cos, tan, atan, asin, acos, sinh, cosh, tanh, exp, log, log10</p><p>·支持运算符：+ - * &#x2F;。可以用^或**来表示多少次方</p><p>·特殊选择方式：</p><p> within 5 of AAA：距离AAA 5埃以内的原子。选取时不考虑周期边界条件，用pbwithin则考虑</p><p> exwithin 5 of AAA ：同上，但不包含AAA自身</p><p> withinbonds 2 of AAA：距离AAA不超过两个键的原子</p><p> same p as AAA：与AAA选区的p属性相同的部分</p><p> ringsize 5 from AAA：处于AAA中五元环上的原子</p><p> maxringsize 6 from AAA：处于AAA中&lt;&#x3D;六元环的原子</p><p>下面来看一些具体例子</p><p> index 5 to 200 210：序号在5~200内的原子以及210号原子</p><p> protein or nucleic：蛋白质与核酸的原子</p><p> resname ALA CYS ARG：丙氨酸、半胱氨酸、精氨酸原子</p><p> backbone not helix：除了螺旋区域以外的骨架原子</p><p> name CA CB 或 name “CA|CB” 或 name “C[AB]” 或 name “C(A|B)”：名为CA和CB的原子</p><p> name “C.”：名字为两个字符且第一个字符为C的原子</p><p> name “CE[1-3]”：名字为CE1、CE2、CE3的原子</p><p> name ‘O5*’：叫O5*的原子。注意原子名带星号的在选取时要用单引号括住以免转义</p><p> resname ‘CA2+’：残基名是CA2+的原子（二价钙离子）。名字带正负号的也要用单引号括住以免转义</p><p> mass &gt; 5：质量大于5的原子</p><p> abs(charge)&gt;1：电荷大小超过1的原子</p><p> x&lt;6 and x&gt;3：选择x在3~6埃区域内的一层原子</p><p> x&gt;1 and x&lt;8 and y&gt;24 and y&lt;35 and z&gt;1 and z&lt;5：一个矩形区域内的原子</p><p> sqr(x-5)+sqr(y+4)+sqr(z) &lt; sqr(5) ：以(5,-4,0)点为中心半径5埃以内的原子</p><p> ((x-33)^2+(y-14.5)^2)&lt;12^2 and z&lt;40 and z&gt;10：选择以x&#x3D;33、y&#x3D;14.5埃为中心，半径为12埃，z范围在10~40埃的柱形区域</p><p> x+y+z&lt;80：斜切面内侧的原子（回忆平面方程）</p><p> not {oxygen and numbonds&#x3D;0}：扣除孤立的氧原子（可以用于去除X光衍射pdb文件里的结晶水）</p><p> within 6 of protein：距离蛋白质6埃以内的原子</p><p> not within 5 of resname ADP：距离名为ADP的分子5埃以外的原子</p><p> water within 5 of residue 8 to 44：距离8~44号残基5埃以内的水</p><p> withinbonds 2 of index 31：距离编号为31原子的两个键及以内的原子</p><p> maxringsize 6 from protein：蛋白当中所有六元及六元以下环上的原子</p><p> same resname as resid 33：所有与33号残基相同名称的残基</p><p> same residue as {protein within 5 of nucleic}：与核酸的原子相距5埃以内的蛋白的原子，并且把被截断的残基保留完整</p><p> x &gt; 15 and not same fragment as {exwithin 8 of protein}：蛋白质以及蛋白质8埃范围以外的原子，保留完整片段，同时x坐标得大于15埃</p><p>以上例子中，涉及到坐标、速度变量的，属于动态选区，即随着帧号变化被选择的原子会可能发生变化。观看这些选区的时候，注意在Representation界面的Trajectory标签页里要把Update Selection Every Frame选上，否则选中的原子是对刚选中时那一帧而言的，不会随着轨迹播放被动态更新。在一些VMD的插件中，比如计算rdf的Radial Pair Distribution Function g(r)插件里，当Selection文本框里用了动态选区时，应当把Update Selections复选框选上，否则也由于不会被动态更新而和期望的不符。</p><blockquote><p>转自 <a href="http://bbs.keinsci.com/thread-14267-1-1.html">http://bbs.keinsci.com/thread-14267-1-1.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VMD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工具网站汇总</title>
    <link href="/2020/05/19/%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99%E6%B1%87%E6%80%BB/"/>
    <url>/2020/05/19/%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="http://tinyambition.com/h2m/">HTML转Markdown</a></li><li><a href="https://pandao.github.io/editor.md/">在线Markdown编辑器</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Matlab绘制图组</title>
    <link href="/2020/05/19/Matlab%E7%BB%98%E5%88%B6%E5%9B%BE%E7%BB%84/"/>
    <url>/2020/05/19/Matlab%E7%BB%98%E5%88%B6%E5%9B%BE%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在用Matlab的<code>subplot</code>函数绘制图组时可能会发现子图之间的间距不太好看，可以通过<code>set(&#39;Position&#39;, [l, b, w, h])</code>函数来分别调整，比较麻烦，这里我写了一个函数<code>subplot_adjust</code>来简化这一过程。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>function <code>subplots_adjust(row, col, varargin)</code></p><p>Tune the subplot layout.</p><p>The parameter meanings (and suggested defaults) are</p><pre><code class="hljs">left = 0.12    # the left side of the subplots of the figurebottom = 0.138 # the bottom of the subplots of the figurewidth = 0.8    # the width of the subplots of the figurehight = 0.78   # the hight of the subplots of the figurewspace = 0.12  # the amount of width reserved for space between subplots,               # expressed as a fraction of the average axis widthhspace = 0.1   # the amount of height reserved for space between subplots,               # expressed as a fraction of the average axis heightsupPosition = [0.075, 0.08, 0.9, 0.85]                # [left, bottom, width, hight]               # super axes position, which controls position of               # supxlabel, supylabel and suptitle.</code></pre><p>在用<code>subplot</code>画完图组后，直接在最后面加上<code>subplot_adjust</code>即可，例如：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs matlab">x = <span class="hljs-built_in">linspace</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>);<br>y1 = <span class="hljs-built_in">sin</span>(x);<br>y2 = <span class="hljs-built_in">cos</span>(x);<br><span class="hljs-built_in">figure</span>(<span class="hljs-string">&#x27;Position&#x27;</span>, [<span class="hljs-number">10</span>, <span class="hljs-number">50</span>, <span class="hljs-number">400</span>, <span class="hljs-number">550</span>]);<br>subplot(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br><span class="hljs-built_in">plot</span>(x, y1)<br>subplot(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-built_in">plot</span>(x, y2)<br>ax = subplots_adjust(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;hspace&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;left&#x27;</span>, <span class="hljs-number">0.2</span>, ...<br>                    <span class="hljs-string">&#x27;width&#x27;</span>, <span class="hljs-number">0.75</span>, <span class="hljs-string">&#x27;supPosition&#x27;</span>, [<span class="hljs-number">0.1</span>, <span class="hljs-number">0.08</span>, <span class="hljs-number">0.95</span>, <span class="hljs-number">0.85</span>]);<br>xlabel(ax, <span class="hljs-string">&#x27;xlabel&#x27;</span>)<br>ylabel(ax, <span class="hljs-string">&#x27;ylabel&#x27;</span>)<br>title(ax, <span class="hljs-string">&#x27;Title&#x27;</span>)<br></code></pre></td></tr></table></figure><p>绘制2行1列图组，设置两子图之间纵向间距为0，结果如下：</p><div align="center"><img src="/2020/05/19/Matlab%E7%BB%98%E5%88%B6%E5%9B%BE%E7%BB%84/2023-04-03-21-08-30.png" width="50%" height="50%"></div><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ax</span> = <span class="hljs-title">subplots_adjust</span><span class="hljs-params">(row, col, varargin)</span></span><br><span class="hljs-comment">%% function subplots_adjust(row, col, varargin)</span><br><span class="hljs-comment">% Tune the subplot layout.</span><br><span class="hljs-comment">% </span><br><span class="hljs-comment">% The parameter meanings (and suggested defaults) are::</span><br><span class="hljs-comment">% </span><br><span class="hljs-comment">%   left = 0.12    # the left side of the subplots of the figure</span><br><span class="hljs-comment">%   bottom = 0.138 # the bottom of the subplots of the figure</span><br><span class="hljs-comment">%   width = 0.8    # the width of the subplots of the figure</span><br><span class="hljs-comment">%   hight = 0.78   # the hight of the subplots of the figure</span><br><span class="hljs-comment">%   wspace = 0.12  # the amount of width reserved for space between subplots,</span><br><span class="hljs-comment">%                  # expressed as a fraction of the average axis width</span><br><span class="hljs-comment">%   hspace = 0.1   # the amount of height reserved for space between subplots,</span><br><span class="hljs-comment">%                  # expressed as a fraction of the average axis height</span><br><span class="hljs-comment">%   supPosition = [0.075, 0.08, 0.9, 0.85] </span><br><span class="hljs-comment">%                  # [left, bottom, width, hight]</span><br><span class="hljs-comment">%                  # super axes position, which controls position of</span><br><span class="hljs-comment">%                  # supxlabel, supylabel and suptitle.</span><br><span class="hljs-comment">%</span><br><span class="hljs-comment">% Example:</span><br><span class="hljs-comment">% x = linspace(0, 10);</span><br><span class="hljs-comment">% y1 = sin(x);</span><br><span class="hljs-comment">% y2 = cos(x);</span><br><span class="hljs-comment">% figure(&#x27;Position&#x27;, [10, 50, 400, 550]);</span><br><span class="hljs-comment">% subplot(2, 1, 1)</span><br><span class="hljs-comment">% plot(x, y1)</span><br><span class="hljs-comment">% subplot(2, 1, 2)</span><br><span class="hljs-comment">% plot(x, y2)</span><br><span class="hljs-comment">% ax = subplots_adjust(2, 1, &#x27;hspace&#x27;, 0, &#x27;left&#x27;, 0.2, ...</span><br><span class="hljs-comment">%                      &#x27;width&#x27;, 0.75, &#x27;supPosition&#x27;, [0.1, 0.08, 0.95, 0.85]);</span><br><span class="hljs-comment">% xlabel(ax, &#x27;xlabel&#x27;)</span><br><span class="hljs-comment">% ylabel(ax, &#x27;ylabel&#x27;)</span><br><span class="hljs-comment">% title(ax, &#x27;Title&#x27;)</span><br><br>p = inputParser;<br>addRequired(p, <span class="hljs-string">&#x27;row&#x27;</span>);<br>addRequired(p, <span class="hljs-string">&#x27;col&#x27;</span>);<br>addParameter(p, <span class="hljs-string">&#x27;wspace&#x27;</span>, <span class="hljs-number">0.12</span>);<br>addParameter(p, <span class="hljs-string">&#x27;hspace&#x27;</span>, <span class="hljs-number">0.1</span>);<br>addParameter(p, <span class="hljs-string">&#x27;left&#x27;</span>, <span class="hljs-number">0.12</span>);<br>addParameter(p, <span class="hljs-string">&#x27;bottom&#x27;</span>, <span class="hljs-number">0.138</span>);<br>addParameter(p, <span class="hljs-string">&#x27;width&#x27;</span>, <span class="hljs-number">0.8</span>);<br>addParameter(p, <span class="hljs-string">&#x27;hight&#x27;</span>, <span class="hljs-number">0.78</span>);<br>addParameter(p, <span class="hljs-string">&#x27;supPosition&#x27;</span>, [<span class="hljs-number">0.075</span>, <span class="hljs-number">0.08</span>, <span class="hljs-number">0.9</span>, <span class="hljs-number">0.85</span>]);<br>parse(p, row, col, varargin&#123;:&#125;);<br><br>left   = p.Results.left;<br>bottom = p.Results.bottom;<br>width  = p.Results.width;<br>hight  = p.Results.hight;<br><br>space = [p.Results.wspace, p.Results.hspace];<br><br>eachx = (width-(col<span class="hljs-number">-1</span>)*space(<span class="hljs-number">1</span>)) / col;<br>eachy = (hight-(row<span class="hljs-number">-1</span>)*space(<span class="hljs-number">2</span>)) / row;<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:row<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span>=<span class="hljs-number">1</span>:col<br>        h = subplot(row, col, (<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)*col+<span class="hljs-built_in">j</span>);<br>        set(h, <span class="hljs-string">&#x27;position&#x27;</span>, [left+(<span class="hljs-built_in">j</span><span class="hljs-number">-1</span>)*(eachx+space(<span class="hljs-number">1</span>)), bottom+(row-<span class="hljs-built_in">i</span>)*(eachy+space(<span class="hljs-number">2</span>)), eachx, eachy]);<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">j</span> ~= <span class="hljs-number">1</span> &amp;&amp; space(<span class="hljs-number">1</span>) == <span class="hljs-number">0</span><br>            set(h, <span class="hljs-string">&#x27;YTickLabel&#x27;</span>, &#123;&#125;);<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">i</span> ~= row &amp;&amp; space(<span class="hljs-number">2</span>) == <span class="hljs-number">0</span><br>            set(h, <span class="hljs-string">&#x27;XTickLabel&#x27;</span>, &#123;&#125;);<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br>ax = axes(<span class="hljs-string">&#x27;Units&#x27;</span>, <span class="hljs-string">&#x27;Normal&#x27;</span>, <span class="hljs-string">&#x27;Position&#x27;</span>, p.Results.supPosition, <span class="hljs-string">&#x27;Visible&#x27;</span>, <span class="hljs-string">&#x27;off&#x27;</span>);<br>ax.XTickLabel = &#123;&#125;;<br>ax.YTickLabel = &#123;&#125;;<br>ax.XLabel.Visible = <span class="hljs-string">&#x27;on&#x27;</span>;<br>ax.YLabel.Visible = <span class="hljs-string">&#x27;on&#x27;</span>;<br>ax.Title.Visible = <span class="hljs-string">&#x27;on&#x27;</span>;<br><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Program</category>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python线程池的创建和使用</title>
    <link href="/2020/05/19/Python%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/05/19/Python%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="✨-前言"><a href="#✨-前言" class="headerlink" title="✨ 前言"></a>✨ 前言</h3><p>从Python3.2开始，标准库为我们提供了 concurrent.futures 模块，它提供了 ThreadPoolExecutor (线程池)和ProcessPoolExecutor (进程池)两个类。</p><p>相比 threading 等模块，该模块通过 submit 返回的是一个 future 对象，它是一个未来可期的对象，通过它可以获悉线程的状态主线程(或进程)中可以获取某一个线程(进程)执行的状态或者某一个任务执行的状态及返回值：</p><ol><li>主线程可以获取某一个线程（或者任务的）的状态，以及返回值。</li><li>当一个线程完成的时候，主线程能够立即知道。</li><li>让多线程和多进程的编码接口一致。</li></ol><h3 id="✨-线程池的基本使用"><a href="#✨-线程池的基本使用" class="headerlink" title="✨ 线程池的基本使用"></a>✨ 线程池的基本使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding: utf-8</span><br><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">spider</span>(<span class="hljs-params">page</span>):<br>    time.sleep(page)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;crawl task<span class="hljs-subst">&#123;page&#125;</span> finished&quot;</span>)<br>    <span class="hljs-keyword">return</span> page<br><br><span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">5</span>) <span class="hljs-keyword">as</span> t:  <span class="hljs-comment"># 创建一个最大容纳数量为5的线程池</span><br>    task1 = t.submit(spider, <span class="hljs-number">1</span>)<br>    task2 = t.submit(spider, <span class="hljs-number">2</span>)  <span class="hljs-comment"># 通过submit提交执行的函数到线程池中</span><br>    task3 = t.submit(spider, <span class="hljs-number">3</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;task1: <span class="hljs-subst">&#123;task1.done()&#125;</span>&quot;</span>)  <span class="hljs-comment"># 通过done来判断线程是否完成</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;task2: <span class="hljs-subst">&#123;task2.done()&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;task3: <span class="hljs-subst">&#123;task3.done()&#125;</span>&quot;</span>)<br><br>    time.sleep(<span class="hljs-number">2.5</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;task1: <span class="hljs-subst">&#123;task1.done()&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;task2: <span class="hljs-subst">&#123;task2.done()&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;task3: <span class="hljs-subst">&#123;task3.done()&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(task1.result())  <span class="hljs-comment"># 通过result来获取返回值</span><br></code></pre></td></tr></table></figure><h5 id="执行结果如下"><a href="#执行结果如下" class="headerlink" title="执行结果如下:"></a>执行结果如下:</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">task1:</span> <span class="hljs-literal">False</span><br><span class="hljs-attr">task2:</span> <span class="hljs-literal">False</span><br><span class="hljs-attr">task3:</span> <span class="hljs-literal">False</span><br><span class="hljs-string">crawl</span> <span class="hljs-string">task1</span> <span class="hljs-string">finished</span><br><span class="hljs-string">crawl</span> <span class="hljs-string">task2</span> <span class="hljs-string">finished</span><br><span class="hljs-attr">task1:</span> <span class="hljs-literal">True</span><br><span class="hljs-attr">task2:</span> <span class="hljs-literal">True</span><br><span class="hljs-attr">task3:</span> <span class="hljs-literal">False</span><br><span class="hljs-number">1</span><br><span class="hljs-string">crawl</span> <span class="hljs-string">task3</span> <span class="hljs-string">finished</span><br></code></pre></td></tr></table></figure><ol><li><p>使用 with 语句 ，通过 ThreadPoolExecutor 构造实例，同时传入 max_workers 参数来设置线程池中最多能同时运行的线程数目。</p></li><li><p>使用 submit 函数来提交线程需要执行的任务到线程池中，并返回该任务的句柄（类似于文件、画图），注意 submit() 不是阻塞的，而是立即返回。</p></li><li><p>通过使用 done() 方法判断该任务是否结束。上面的例子可以看出，提交任务后立即判断任务状态，显示四个任务都未完成。在延时2.5后，task1 和 task2 执行完毕，task3 仍在执行中。</p></li><li><p>使用 result() 方法可以获取任务的返回值。</p></li></ol><h3 id="✨-主要方法："><a href="#✨-主要方法：" class="headerlink" title="✨ 主要方法："></a>✨ 主要方法：</h3><h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">wait(fs, <span class="hljs-attribute">timeout</span>=None, <span class="hljs-attribute">return_when</span>=ALL_COMPLETED)<br></code></pre></td></tr></table></figure><p>wait 接受三个参数： fs: 表示需要执行的序列 timeout: 等待的最大时间，如果超过这个时间即使线程未执行完成也将返回 return_when：表示wait返回结果的条件，默认为 ALL_COMPLETED 全部执行完成再返回</p><p>还是用上面那个例子来熟悉用法 示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor, wait, FIRST_COMPLETED, ALL_COMPLETED<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">spider</span>(<span class="hljs-params">page</span>):<br>    time.sleep(page)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;crawl task<span class="hljs-subst">&#123;page&#125;</span> finished&quot;</span>)<br>    <span class="hljs-keyword">return</span> page<br><br><span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">5</span>) <span class="hljs-keyword">as</span> t: <br>    all_task = [t.submit(spider, page) <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)]<br>    wait(all_task, return_when=FIRST_COMPLETED)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;finished&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(wait(all_task, timeout=<span class="hljs-number">2.5</span>))<br><br><span class="hljs-comment"># 运行结果</span><br>crawl task1 finished<br>finished<br>crawl task2 finished<br>crawl task3 finished<br>DoneAndNotDoneFutures(done=&#123;, , &#125;, not_done=&#123;&#125;)<br>crawl task4 finished<br></code></pre></td></tr></table></figure><ol><li>代码中返回的条件是：当完成第一个任务的时候，就停止等待，继续主线程任务</li><li>由于设置了延时， 可以看到最后只有 task4 还在运行中</li></ol><h4 id="as-completed"><a href="#as-completed" class="headerlink" title="as_completed"></a>as_completed</h4><p>上面虽然提供了判断任务是否结束的方法，但是不能在主线程中一直判断啊。最好的方法是当某个任务结束了，就给主线程返回结果，而不是一直判断每个任务是否结束。</p><p>ThreadPoolExecutorThreadPoolExecutor 中 的 as_completed() 就是这样一个方法，当子线程中的任务执行完后，直接用 result() 获取返回结果</p><p>用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding: utf-8</span><br><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor, as_completed<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">spider</span>(<span class="hljs-params">page</span>):<br>    time.sleep(page)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;crawl task<span class="hljs-subst">&#123;page&#125;</span> finished&quot;</span>)<br>    <span class="hljs-keyword">return</span> page<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">5</span>) <span class="hljs-keyword">as</span> t:<br>        obj_list = []<br>        <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>):<br>            obj = t.submit(spider, page)<br>            obj_list.append(obj)<br><br>        <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> as_completed(obj_list):<br>            data = future.result()<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;main: <span class="hljs-subst">&#123;data&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 执行结果</span><br>crawl task1 finished<br>main: <span class="hljs-number">1</span><br>crawl task2 finished<br>main: <span class="hljs-number">2</span><br>crawl task3 finished<br>main: <span class="hljs-number">3</span><br>crawl task4 finished<br>main: <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>as_completed() 方法是一个生成器，在没有任务完成的时候，会一直阻塞，除非设置了 timeout。</p><p>当有某个任务完成的时候，会 yield 这个任务，就能执行 for 循环下面的语句，然后继续阻塞住，循环到所有的任务结束。同时，先完成的任务会先返回给主线程。</p><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">map</span><span class="hljs-params">(fn, *iterables, timeout=None)</span></span><br></code></pre></td></tr></table></figure><p>fn： 第一个参数 fn 是需要线程执行的函数； iterables：第二个参数接受一个可迭代对象； timeout： 第三个参数 timeout 跟 wait() 的 timeout 一样，但由于 map 是返回线程执行的结果，如果 timeout小于线程执行时间会抛异常 TimeoutError。</p><p>用法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">spider</span>(<span class="hljs-params">page</span>):<br>    time.sleep(page)<br>    <span class="hljs-keyword">return</span> page<br><br>start = time.time()<br>executor = ThreadPoolExecutor(max_workers=<span class="hljs-number">4</span>)<br><br>i = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> executor.<span class="hljs-built_in">map</span>(spider, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>]):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;task&#123;&#125;:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i, result))<br>    i += <span class="hljs-number">1</span><br><br><span class="hljs-comment">#  运行结果</span><br>task1:<span class="hljs-number">2</span><br>task2:<span class="hljs-number">3</span><br>task3:<span class="hljs-number">1</span><br>task4:<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>使用 map 方法，无需提前使用 submit 方法，map 方法与 python 高阶函数 map 的含义相同，都是将序列中的每个元素都执行同一个函数。</p><p>上面的代码对列表中的每个元素都执行 spider() 函数，并分配各线程池。</p><p>可以看到执行结果与上面的 as_completed() 方法的结果不同，输出顺序和列表的顺序相同，就算 1s 的任务先执行完成，也会先打印前面提交的任务返回的结果。</p><h3 id="✨-实战"><a href="#✨-实战" class="headerlink" title="✨ 实战"></a>✨ 实战</h3><p>以某网站为例，演示线程池和单线程两种方式爬取的差异</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding: utf-8</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor, as_completed<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">from</span> requests <span class="hljs-keyword">import</span> adapters<br><br><span class="hljs-keyword">from</span> proxy <span class="hljs-keyword">import</span> get_proxies<br><br>headers = &#123;<br>    <span class="hljs-string">&quot;Host&quot;</span>: <span class="hljs-string">&quot;splcgk.court.gov.cn&quot;</span>,<br>    <span class="hljs-string">&quot;Origin&quot;</span>: <span class="hljs-string">&quot;https://splcgk.court.gov.cn&quot;</span>,<br>    <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&quot;</span>,<br>    <span class="hljs-string">&quot;Referer&quot;</span>: <span class="hljs-string">&quot;https://splcgk.court.gov.cn/gzfwww/ktgg&quot;</span>,<br>&#125;<br>url = <span class="hljs-string">&quot;https://splcgk.court.gov.cn/gzfwww/ktgglist?pageNo=1&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">spider</span>(<span class="hljs-params">page</span>):<br>    data = &#123;<br>        <span class="hljs-string">&quot;bt&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-string">&quot;fydw&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-string">&quot;pageNum&quot;</span>: page,<br>    &#125;<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        <span class="hljs-keyword">try</span>:<br>            response = requests.post(url, headers=headers, data=data, proxies=get_proxies())<br>            json_data = response.json()<br>        <span class="hljs-keyword">except</span> (json.JSONDecodeError, adapters.SSLError):<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> &#123;&#125;<br><br>    <span class="hljs-keyword">return</span> json_data<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">8</span>) <span class="hljs-keyword">as</span> t:<br>        obj_list = []<br>        begin = time.time()<br>        <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">15</span>):<br>            obj = t.submit(spider, page)<br>            obj_list.append(obj)<br><br>        <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> as_completed(obj_list):<br>            data = future.result()<br>            <span class="hljs-built_in">print</span>(data)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;*&#x27;</span> * <span class="hljs-number">50</span>)<br>        times = time.time() - begin<br>        <span class="hljs-built_in">print</span>(times)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/6/16b2cf5c38d862ef?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="多线程"></p><p><strong>可以看到，14 页只花了 2 秒钟就爬完了</strong></p><p>下面我们可以使用单线程来爬取，代码基本和上面的一样，加个单线程函数 代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">single</span>():<br>    begin = time.time()<br>    <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">15</span>):<br>        data = spider(page)<br>        <span class="hljs-built_in">print</span>(data)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;*&#x27;</span> * <span class="hljs-number">50</span>)<br><br>    times = time.time() - begin<br>    <span class="hljs-built_in">print</span>(times)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    single()<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/6/16b2cf5c38438238?imageslim" alt="单线程"></p><p><strong>可以看到，总共花了 19 秒。真是肉眼可见的差距啊！如果数据量大的话，运行时间差距会更大！</strong></p><blockquote><p>转自：<a href="https://juejin.im/post/5cf913cfe51d45105d63a4d0">https://juejin.im/post/5cf913cfe51d45105d63a4d0</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Program</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
